#!/usr/bin/env bash
# scripts/bootstrap - Quality checks before quench can check itself
#
# These checks will be replaced by `quench check` once implemented.
# Until then, this script enforces the same rules.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

cd "$PROJECT_ROOT"

RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m'

failed=0

# --- File size limits ---
echo "Checking file sizes..."

# Defaults from docs/specs/checks/cloc.md
MAX_SOURCE=750
MAX_TEST=1100

source_size_failed=0
test_size_failed=0
# Exclude benchmark fixtures and CLOC test fixtures (generated files with intentionally large sizes)
files=$(rg --files --type rust crates tests --glob '!tests/fixtures/bench-*' --glob '!tests/fixtures/cloc/*' 2>/dev/null)
if [[ -n "$files" ]]; then
    # Batch wc -l call (35x faster than per-file)
    while read -r line; do
        # Parse "  123 path/to/file.rs" format
        lines=$(echo "$line" | awk '{print $1}')
        file=$(echo "$line" | awk '{print $2}')

        # Skip the "total" line from wc -l
        [[ "$file" == "total" ]] && continue

        # Test files: tests/**, *_tests.rs, *_test.rs, *_tests/**
        if [[ "$file" == tests/* || "$file" == *"_tests.rs" || "$file" == *"_test.rs" || "$file" == *"_tests/"* ]]; then
            if [ "$lines" -gt "$MAX_TEST" ]; then
                echo -e "${RED}$file: $lines lines (max: $MAX_TEST)${NC}"
                test_size_failed=1
            fi
        else
            if [ "$lines" -gt "$MAX_SOURCE" ]; then
                echo -e "${RED}$file: $lines lines (max: $MAX_SOURCE)${NC}"
                source_size_failed=1
            fi
        fi
    done < <(echo "$files" | xargs wc -l)
fi

if [ $source_size_failed -eq 0 ] && [ $test_size_failed -eq 0 ]; then
    echo -e "${GREEN}File sizes OK${NC}"
else
    if [ $source_size_failed -eq 1 ]; then
        echo -e "Split large source files into sibling modules or submodules in a folder; consider refactoring to be more unit testable"
    fi
    if [ $test_size_failed -eq 1 ]; then
        echo -e "Split large test files into a {module}_tests/ folder"
    fi
    failed=1
fi

# --- Dead code allowances ---
echo ""
echo "Checking for unauthorized #[allow(dead_code)]..."

# Find #[allow(dead_code)] without "// KEEP UNTIL:" comment on same line
DEAD_CODE=$(rg -n '#\[allow\(dead_code\)\]' --type rust crates 2>/dev/null | \
    rg -v '// KEEP UNTIL:' || true)

if [[ -n "$DEAD_CODE" ]]; then
    echo -e "${RED}Found #[allow(dead_code)] without timeline:${NC}"
    echo "$DEAD_CODE"
    echo -e "Add '// KEEP UNTIL: <condition>' comment to suppress"
    failed=1
else
    echo -e "${GREEN}No unauthorized dead code allowances${NC}"
fi

# --- Test file convention ---
echo ""
echo "Checking test file convention..."

# Find inline #[cfg(test)] mod tests { patterns (should use _tests.rs instead)
# Exclude _tests.rs files and files using #[path = "..."] pattern
INLINE_TESTS=$(rg -n '#\[cfg\(test\)\]' --type rust crates \
    --glob '!*_tests.rs' 2>/dev/null | \
    rg -v '#\[path = "' || true)

if [[ -n "$INLINE_TESTS" ]]; then
    while IFS=: read -r file line _; do
        # Get this line and next line
        context=$(sed -n "${line},$((line+1))p" "$file")
        if echo "$context" | rg -q 'mod tests'; then
            echo -e "${RED}$file:$line: inline #[cfg(test)] mod tests - use _tests.rs file instead${NC}"
            failed=1
        fi
    done <<< "$INLINE_TESTS"
fi

if [ $failed -eq 0 ]; then
    echo -e "${GREEN}Test conventions OK${NC}"
fi

# --- Summary ---
echo ""
if [ $failed -eq 0 ]; then
    echo -e "${GREEN}All bootstrap checks passed${NC}"
    exit 0
else
    echo -e "${RED}Bootstrap checks failed${NC}"
    exit 1
fi
