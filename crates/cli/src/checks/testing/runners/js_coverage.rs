// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Alfred Jean LLC

//! JavaScript coverage collection via LCOV format parsing.
//!
//! Parses LCOV format coverage reports generated by Jest, Vitest, and Bun.
//! LCOV is the de facto standard for JavaScript coverage tools.

use std::collections::HashMap;
use std::path::Path;
use std::process::{Command, Stdio};
use std::time::{Duration, Instant};

use super::CoverageResult;
use crate::adapter::javascript::PackageManager;

// =============================================================================
// Coverage Collection Functions
// =============================================================================

/// Collect Jest coverage.
///
/// Runs jest with coverage using the detected package manager's exec command.
/// Returns a skipped result if jest is not available.
pub fn collect_jest_coverage(root: &Path, test_path: Option<&str>) -> CoverageResult {
    let start = Instant::now();

    let pkg_mgr = PackageManager::detect(root);
    let exec_cmd = pkg_mgr.exec_command();

    let mut cmd = Command::new(&exec_cmd[0]);
    cmd.args(&exec_cmd[1..]);
    cmd.args(["jest", "--coverage", "--coverageReporters=lcov"]);
    if let Some(path) = test_path {
        cmd.arg(path);
    }
    cmd.current_dir(root);
    cmd.stdout(Stdio::piped());
    cmd.stderr(Stdio::piped());

    let output = match cmd.output() {
        Ok(out) => out,
        Err(e) => {
            return CoverageResult::failed(
                start.elapsed(),
                format!("failed to run jest coverage: {e}"),
            );
        }
    };

    let duration = start.elapsed();

    // Jest writes to coverage/lcov.info by default
    let lcov_path = root.join("coverage/lcov.info");
    match std::fs::read_to_string(&lcov_path) {
        Ok(content) => {
            // Cleanup coverage directory
            std::fs::remove_dir_all(root.join("coverage")).ok();
            parse_lcov_report(&content, duration)
        }
        Err(e) => {
            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                let msg = stderr.lines().take(10).collect::<Vec<_>>().join("\n");
                return CoverageResult::failed(duration, format!("jest failed:\n{msg}"));
            }
            CoverageResult::failed(duration, format!("no coverage output: {e}"))
        }
    }
}

/// Collect Vitest coverage.
///
/// Runs vitest with coverage using the detected package manager's exec command.
pub fn collect_vitest_coverage(root: &Path, test_path: Option<&str>) -> CoverageResult {
    let start = Instant::now();

    let pkg_mgr = PackageManager::detect(root);
    let exec_cmd = pkg_mgr.exec_command();

    let mut cmd = Command::new(&exec_cmd[0]);
    cmd.args(&exec_cmd[1..]);
    cmd.args(["vitest", "run", "--coverage", "--coverage.reporter=lcov"]);
    if let Some(path) = test_path {
        cmd.arg(path);
    }
    cmd.current_dir(root);
    cmd.stdout(Stdio::piped());
    cmd.stderr(Stdio::piped());

    let output = match cmd.output() {
        Ok(out) => out,
        Err(e) => {
            return CoverageResult::failed(
                start.elapsed(),
                format!("failed to run vitest coverage: {e}"),
            );
        }
    };

    let duration = start.elapsed();

    // Vitest writes to coverage/lcov.info by default
    let lcov_path = root.join("coverage/lcov.info");
    match std::fs::read_to_string(&lcov_path) {
        Ok(content) => {
            // Cleanup coverage directory
            std::fs::remove_dir_all(root.join("coverage")).ok();
            parse_lcov_report(&content, duration)
        }
        Err(e) => {
            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                let msg = stderr.lines().take(10).collect::<Vec<_>>().join("\n");
                return CoverageResult::failed(duration, format!("vitest failed:\n{msg}"));
            }
            CoverageResult::failed(duration, format!("no coverage output: {e}"))
        }
    }
}

/// Collect Bun coverage.
///
/// Runs `bun test --coverage` and parses LCOV output.
pub fn collect_bun_coverage(root: &Path, test_path: Option<&str>) -> CoverageResult {
    let start = Instant::now();

    let mut cmd = Command::new("bun");
    cmd.args(["test", "--coverage", "--coverage-reporter=lcov"]);
    if let Some(path) = test_path {
        cmd.arg(path);
    }
    cmd.current_dir(root);
    cmd.stdout(Stdio::piped());
    cmd.stderr(Stdio::piped());

    let output = match cmd.output() {
        Ok(out) => out,
        Err(e) => {
            return CoverageResult::failed(
                start.elapsed(),
                format!("failed to run bun coverage: {e}"),
            );
        }
    };

    let duration = start.elapsed();

    // Bun writes to coverage/lcov.info by default
    let lcov_path = root.join("coverage/lcov.info");
    match std::fs::read_to_string(&lcov_path) {
        Ok(content) => {
            // Cleanup coverage directory
            std::fs::remove_dir_all(root.join("coverage")).ok();
            parse_lcov_report(&content, duration)
        }
        Err(e) => {
            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                let msg = stderr.lines().take(10).collect::<Vec<_>>().join("\n");
                return CoverageResult::failed(duration, format!("bun failed:\n{msg}"));
            }
            CoverageResult::failed(duration, format!("no coverage output: {e}"))
        }
    }
}

// =============================================================================
// LCOV Parsing
// =============================================================================

/// Parse LCOV format coverage report.
///
/// LCOV is the de facto standard for JavaScript coverage tools.
/// All major JS test runners output this format.
///
/// LCOV format:
/// ```text
/// TN:testname
/// SF:/path/to/source.js
/// FN:1,functionName
/// FNDA:1,functionName
/// FNF:1
/// FNH:1
/// DA:1,1
/// DA:2,3
/// DA:3,0
/// LF:3
/// LH:2
/// end_of_record
/// ```
///
/// Key fields:
/// - `SF:` - Source file path
/// - `DA:line,count` - Line data: line number and execution count
/// - `LF:` - Lines found (total)
/// - `LH:` - Lines hit (covered)
/// - `end_of_record` - Marks end of file record
pub fn parse_lcov_report(content: &str, duration: Duration) -> CoverageResult {
    let mut file_stats: HashMap<String, (u64, u64)> = HashMap::new(); // (hit, found)
    let mut current_file: Option<String> = None;
    let mut current_hit: u64 = 0;
    let mut current_found: u64 = 0;

    for line in content.lines() {
        let line = line.trim();
        if let Some(path) = line.strip_prefix("SF:") {
            current_file = Some(path.to_string());
            current_hit = 0;
            current_found = 0;
        } else if let Some(value) = line.strip_prefix("LH:") {
            current_hit = value.parse().unwrap_or(0);
        } else if let Some(value) = line.strip_prefix("LF:") {
            current_found = value.parse().unwrap_or(0);
        } else if line == "end_of_record" {
            if let Some(ref file) = current_file {
                let normalized = normalize_js_path(file);
                // Skip node_modules and empty paths
                if !normalized.is_empty() && should_include_file(file) {
                    file_stats.insert(normalized, (current_hit, current_found));
                }
            }
            current_file = None;
        }
    }

    calculate_coverage_result(file_stats, duration)
}

/// Calculate CoverageResult from file statistics.
fn calculate_coverage_result(
    file_stats: HashMap<String, (u64, u64)>,
    duration: Duration,
) -> CoverageResult {
    if file_stats.is_empty() {
        return CoverageResult {
            success: true,
            error: None,
            duration,
            line_coverage: None,
            files: HashMap::new(),
            packages: HashMap::new(),
        };
    }

    // Convert to percentages and aggregate by package
    let mut files: HashMap<String, f64> = HashMap::new();
    let mut package_stats: HashMap<String, (u64, u64)> = HashMap::new(); // (hit, found)
    let mut total_hit: u64 = 0;
    let mut total_found: u64 = 0;

    for (path, (hit, found)) in &file_stats {
        if *found > 0 {
            let pct = (*hit as f64 / *found as f64) * 100.0;
            files.insert(path.clone(), pct);

            // Aggregate by package
            let package = extract_js_package(path);
            let pkg_entry = package_stats.entry(package).or_default();
            pkg_entry.0 += hit;
            pkg_entry.1 += found;

            // Aggregate totals
            total_hit += hit;
            total_found += found;
        }
    }

    // Calculate per-package percentages
    let packages: HashMap<String, f64> = package_stats
        .into_iter()
        .filter(|(_, (_, found))| *found > 0)
        .map(|(pkg, (hit, found))| {
            let pct = (hit as f64 / found as f64) * 100.0;
            (pkg, pct)
        })
        .collect();

    // Calculate overall line coverage
    let line_coverage = if total_found > 0 {
        Some((total_hit as f64 / total_found as f64) * 100.0)
    } else {
        None
    };

    CoverageResult {
        success: true,
        error: None,
        duration,
        line_coverage,
        files,
        packages,
    }
}

// =============================================================================
// Path Handling
// =============================================================================

/// Check if a file should be included in coverage.
///
/// Always exclude node_modules from coverage metrics.
fn should_include_file(path: &str) -> bool {
    !path.contains("node_modules")
}

/// Normalize JavaScript file path for display.
///
/// Removes absolute path prefix and filters out problematic paths.
/// Returns empty string for files that should be excluded.
pub fn normalize_js_path(path: &str) -> String {
    // Skip node_modules entirely
    if path.contains("node_modules") {
        return String::new();
    }

    // Find project-relative path markers
    // Check monorepo patterns first (packages/, apps/, libs/) before src/
    for marker in [
        "packages/",
        "apps/",
        "libs/",
        "src/",
        "lib/",
        "dist/",
        "tests/",
    ] {
        if let Some(idx) = path.find(marker) {
            return path[idx..].to_string();
        }
    }

    // Fallback: use filename only
    path.rsplit('/').next().unwrap_or(path).to_string()
}

/// Extract JavaScript package name from file path.
///
/// JavaScript projects use various monorepo structures:
/// - `packages/<name>/src/*` - npm workspaces
/// - `apps/<name>/src/*` - turborepo/nx pattern
/// - `libs/<name>/src/*` - library pattern
/// - `src/*` - single package
///
/// Examples:
/// - `packages/core/src/index.ts` -> `packages/core`
/// - `apps/web/components/Button.tsx` -> `apps/web`
/// - `src/utils/format.js` -> `root`
pub fn extract_js_package(path: &str) -> String {
    // Check for workspace patterns
    for marker in ["packages/", "apps/", "libs/"] {
        if let Some(idx) = path.find(marker) {
            let after_marker = &path[idx + marker.len()..];
            // Find first slash after package name
            if let Some(slash_idx) = after_marker.find('/') {
                let pkg_name = &after_marker[..slash_idx];
                return format!("{}{}", marker, pkg_name);
            }
        }
    }
    "root".to_string()
}

#[cfg(test)]
#[path = "js_coverage_tests.rs"]
mod tests;
