// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Alfred Jean LLC

//! SimpleCov coverage parsing for Ruby projects.
//!
//! Reads coverage data from `coverage/.resultset.json` generated by SimpleCov.

use std::collections::HashMap;
use std::path::Path;
use std::time::{Duration, Instant};

use serde::Deserialize;

use super::CoverageResult;

/// Collect Ruby coverage from SimpleCov's .resultset.json.
///
/// SimpleCov writes coverage data to `coverage/.resultset.json` after test runs.
/// This function parses that file and returns coverage metrics.
pub fn collect_ruby_coverage(root: &Path) -> CoverageResult {
    let resultset_path = root.join("coverage/.resultset.json");

    if !resultset_path.exists() {
        return CoverageResult::skipped();
    }

    let start = Instant::now();

    let content = match std::fs::read_to_string(&resultset_path) {
        Ok(c) => c,
        Err(e) => {
            return CoverageResult::failed(
                start.elapsed(),
                format!("failed to read coverage file: {e}"),
            );
        }
    };

    parse_simplecov_json(&content, start.elapsed())
}

/// SimpleCov .resultset.json structure.
///
/// Format:
/// ```json
/// {
///   "RSpec": {
///     "coverage": {
///       "/path/to/lib/math.rb": {
///         "lines": [1, 1, null, 0, 1, null]
///       }
///     },
///     "timestamp": 1234567890
///   }
/// }
/// ```
#[derive(Debug, Deserialize)]
struct SimpleCovResultset {
    #[serde(flatten)]
    suites: HashMap<String, SimpleCovSuite>,
}

#[derive(Debug, Deserialize)]
struct SimpleCovSuite {
    coverage: HashMap<String, SimpleCovFile>,
    #[allow(dead_code)]
    timestamp: Option<u64>,
}

/// Coverage data for a single file.
///
/// SimpleCov can use two formats:
/// 1. Modern format: `{"lines": [1, 1, null, 0, ...]}`
/// 2. Legacy format: `[1, 1, null, 0, ...]` (array directly)
#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum SimpleCovFile {
    Modern { lines: Vec<Option<u64>> },
    Legacy(Vec<Option<u64>>),
}

impl SimpleCovFile {
    fn lines(&self) -> &[Option<u64>] {
        match self {
            SimpleCovFile::Modern { lines } => lines,
            SimpleCovFile::Legacy(lines) => lines,
        }
    }
}

/// Parse SimpleCov JSON content.
pub(crate) fn parse_simplecov_json(json: &str, duration: Duration) -> CoverageResult {
    let resultset: SimpleCovResultset = match serde_json::from_str(json) {
        Ok(r) => r,
        Err(e) => {
            return CoverageResult::failed(
                duration,
                format!("failed to parse SimpleCov JSON: {e}"),
            );
        }
    };

    let mut files: HashMap<String, f64> = HashMap::new();
    let mut package_files: HashMap<String, Vec<f64>> = HashMap::new();

    // Merge coverage from all suites (RSpec, Minitest, etc.)
    for suite in resultset.suites.values() {
        for (file_path, file_data) in &suite.coverage {
            let coverage = calculate_line_coverage(file_data.lines());
            if let Some(pct) = coverage {
                let normalized_path = normalize_ruby_path(file_path);
                files.insert(normalized_path.clone(), pct);

                let package = extract_ruby_package(&normalized_path);
                package_files.entry(package).or_default().push(pct);
            }
        }
    }

    if files.is_empty() {
        return CoverageResult {
            success: true,
            error: None,
            duration,
            line_coverage: None,
            files: HashMap::new(),
            packages: HashMap::new(),
        };
    }

    // Calculate overall coverage as average of all files
    let total_coverage = files.values().sum::<f64>() / files.len() as f64;

    // Calculate per-package averages
    let packages: HashMap<String, f64> = package_files
        .into_iter()
        .map(|(pkg, coverages)| {
            let avg = coverages.iter().sum::<f64>() / coverages.len() as f64;
            (pkg, avg)
        })
        .collect();

    CoverageResult {
        success: true,
        error: None,
        duration,
        line_coverage: Some(total_coverage),
        files,
        packages,
    }
}

/// Calculate line coverage percentage from SimpleCov line data.
///
/// SimpleCov line data format:
/// - `null` = line not relevant (comments, blank lines, etc.)
/// - `0` = line not covered
/// - `n > 0` = line covered n times
fn calculate_line_coverage(lines: &[Option<u64>]) -> Option<f64> {
    let mut covered = 0u64;
    let mut total = 0u64;

    for count in lines.iter().flatten() {
        total += 1;
        if *count > 0 {
            covered += 1;
        }
    }

    if total == 0 {
        None
    } else {
        Some((covered as f64 / total as f64) * 100.0)
    }
}

/// Normalize Ruby file paths to project-relative.
fn normalize_ruby_path(path: &str) -> String {
    // Look for common Ruby project markers
    for marker in ["lib/", "app/", "src/"] {
        if let Some(idx) = path.find(marker) {
            return path[idx..].to_string();
        }
    }

    // Fallback: use filename only
    std::path::Path::new(path)
        .file_name()
        .map(|s| s.to_string_lossy().to_string())
        .unwrap_or_else(|| path.to_string())
}

/// Extract package name from Ruby file path.
///
/// Heuristics:
/// - Look for "lib/<name>/" or "app/<name>/" patterns
/// - For gems, the top-level directory under lib/ is the package
/// - Fallback to "root"
fn extract_ruby_package(path: &str) -> String {
    // Check for "lib/<name>/" pattern (Ruby gem structure)
    if let Some(rest) = path.strip_prefix("lib/")
        && let Some(end) = rest.find('/')
    {
        return rest[..end].to_string();
    }

    // Check for "app/<name>/" pattern (Rails structure)
    if let Some(rest) = path.strip_prefix("app/")
        && let Some(end) = rest.find('/')
    {
        return rest[..end].to_string();
    }

    // Fallback to "root"
    "root".to_string()
}

#[cfg(test)]
#[path = "ruby_coverage_tests.rs"]
mod tests;
