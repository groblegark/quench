# Phase 4481: Python Test Runners - Coverage

## Overview

Add coverage.py integration to the Python test runner. This enables collecting line coverage metrics when running Python tests via pytest. Supports both `coverage run -m pytest` and `pytest --cov` invocation styles, with report parsing for `.coverage` (SQLite), `coverage.xml` (Cobertura), and `coverage.json` formats.

## Project Structure

```
crates/cli/src/checks/tests/runners/
├── mod.rs                    # Add python_coverage module, update AggregatedCoverage
├── pytest.rs                 # Modify to collect coverage when ctx.collect_coverage
├── python_coverage.rs        # NEW: Python coverage collection and parsing
└── python_coverage_tests.rs  # NEW: Unit tests for coverage parsing

tests/fixtures/
└── python/
    └── coverage-simple/      # NEW: Simple Python project with coverage setup
        ├── pyproject.toml
        ├── quench.toml
        ├── src/myproject/
        │   ├── __init__.py
        │   └── math.py
        └── tests/
            └── test_math.py
```

## Dependencies

- `serde` / `serde_json` - Already in project, for JSON parsing
- No new external dependencies required

## Implementation Phases

### Phase 1: Python Coverage Module

Create `crates/cli/src/checks/tests/runners/python_coverage.rs` with core coverage collection and parsing logic.

**Key components:**

```rust
// Check if coverage.py is available
pub fn coverage_available() -> bool {
    // Cache result like go_available()
    Command::new("coverage").arg("--version").status().is_ok_and(|s| s.success())
}

// Check if pytest-cov is available
pub fn pytest_cov_available() -> bool {
    Command::new("pytest").args(["--cov-help"]).status().is_ok_and(|s| s.success())
}

// Main entry point for collecting Python coverage
pub fn collect_python_coverage(root: &Path, test_path: Option<&str>) -> CoverageResult {
    // Strategy:
    // 1. Try pytest --cov if pytest-cov available
    // 2. Fallback to coverage run -m pytest
    // 3. Parse .coverage, coverage.json, or coverage.xml in priority order
}
```

**Coverage.json format (preferred):**
```json
{
  "meta": {"version": "7.4.0", "branch_coverage": true},
  "files": {
    "/path/to/src/math.py": {
      "executed_lines": [1, 2, 5, 6, 7],
      "missing_lines": [10, 11],
      "excluded_lines": [],
      "summary": {"covered_lines": 5, "num_statements": 7, "percent_covered": 71.43}
    }
  },
  "totals": {"covered_lines": 25, "num_statements": 30, "percent_covered": 83.33}
}
```

**Cobertura XML format (coverage.xml):**
```xml
<coverage version="7.4.0" timestamp="..." lines-valid="30" lines-covered="25" line-rate="0.8333">
  <packages>
    <package name="src.myproject">
      <classes>
        <class name="math.py" filename="src/myproject/math.py" line-rate="0.7143">
          <lines>
            <line number="1" hits="1"/>
            <line number="10" hits="0"/>
          </lines>
        </class>
      </classes>
    </package>
  </packages>
</coverage>
```

### Phase 2: JSON Parser Implementation

Implement coverage.json parsing (simplest and most reliable):

```rust
#[derive(Deserialize)]
struct CoverageJson {
    meta: CoverageMeta,
    files: HashMap<String, FileData>,
    totals: TotalsData,
}

#[derive(Deserialize)]
struct CoverageMeta {
    branch_coverage: Option<bool>,
}

#[derive(Deserialize)]
struct FileData {
    executed_lines: Vec<u32>,
    missing_lines: Vec<u32>,
    summary: FileSummary,
}

#[derive(Deserialize)]
struct FileSummary {
    covered_lines: u64,
    num_statements: u64,
    percent_covered: f64,
}

#[derive(Deserialize)]
struct TotalsData {
    covered_lines: u64,
    num_statements: u64,
    percent_covered: f64,
}

pub fn parse_coverage_json(json: &str, duration: Duration) -> CoverageResult {
    // Parse JSON
    // Extract per-file coverage percentages
    // Group by Python package (src/package_name/)
    // Return CoverageResult
}
```

### Phase 3: XML Parser Implementation

Implement Cobertura XML parsing as fallback:

```rust
pub fn parse_cobertura_xml(xml: &str, duration: Duration) -> CoverageResult {
    // Parse XML using quick-xml or roxmltree (already in project)
    // Extract line-rate from <coverage> element
    // Extract per-file data from <class> elements
    // Group by package from <package> names
}
```

Quick-xml pattern (if available):
```rust
use quick_xml::Reader;
use quick_xml::events::Event;

fn parse_cobertura(content: &str) -> CoverageResult {
    let mut reader = Reader::from_str(content);
    // Parse coverage element attributes for overall coverage
    // Parse class elements for per-file coverage
}
```

### Phase 4: Pytest Runner Integration

Modify `pytest.rs` to collect coverage when `ctx.collect_coverage` is true:

```rust
impl TestRunner for PytestRunner {
    fn run(&self, config: &TestSuiteConfig, ctx: &RunnerContext) -> TestRunResult {
        // ... existing test execution ...

        // After running tests, collect coverage if requested
        if ctx.collect_coverage {
            let coverage = collect_python_coverage(ctx.root, config.path.as_deref());
            result = result.with_collected_coverage(coverage, "python");
        }

        result
    }
}
```

**Coverage collection strategy in pytest runner:**
1. Run `pytest --cov=src --cov-report=json` if pytest-cov available
2. Or run `coverage run -m pytest && coverage json` if coverage.py available
3. Look for `coverage.json` first, then `.coverage` + generate JSON, then `coverage.xml`
4. Parse and return `CoverageResult`

### Phase 5: Coverage Aggregation

Update `crates/cli/src/checks/tests/runners/mod.rs` to support Python coverage:

```rust
/// Aggregated coverage across all test suites.
#[derive(Debug, Default)]
pub struct AggregatedCoverage {
    pub rust: Option<CoverageResult>,
    pub shell: Option<CoverageResult>,
    pub go: Option<CoverageResult>,
    pub javascript: Option<CoverageResult>,
    pub ruby: Option<CoverageResult>,
    pub python: Option<CoverageResult>,  // NEW
}

impl AggregatedCoverage {
    /// Merge Python coverage from a suite into the aggregate.
    pub fn merge_python(&mut self, result: CoverageResult) {
        self.python = Some(match self.python.take() {
            Some(existing) => merge_coverage_results(existing, result),
            None => result,
        });
    }

    /// Convert to a language -> percentage map for metrics.
    pub fn to_coverage_map(&self) -> HashMap<String, f64> {
        // ... existing languages ...
        if let Some(ref python) = self.python
            && let Some(pct) = python.line_coverage
        {
            map.insert("python".to_string(), pct);
        }
        map
    }

    pub fn has_data(&self) -> bool {
        // ... existing checks ...
        || self.python.as_ref().is_some_and(|r| r.line_coverage.is_some())
    }
}
```

### Phase 6: Test Fixture and Unit Tests

**Create test fixture:** `tests/fixtures/python/coverage-simple/`

**pyproject.toml:**
```toml
[project]
name = "myproject"
version = "0.1.0"
requires-python = ">=3.10"

[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[tool.setuptools.packages.find]
where = ["src"]

[tool.pytest.ini_options]
addopts = "--cov=myproject --cov-report=json"

[tool.coverage.run]
source = ["src"]
branch = true

[tool.coverage.report]
exclude_lines = ["pragma: no cover", "if TYPE_CHECKING:"]
```

**quench.toml:**
```toml
version = 1

[project]
name = "python-coverage-simple"

[[check.tests.suite]]
runner = "pytest"
```

**Unit tests for parsers:** `python_coverage_tests.rs`
```rust
#[test]
fn parses_coverage_json() {
    let json = r#"{
        "meta": {"version": "7.4.0"},
        "files": {
            "/src/myproject/math.py": {
                "executed_lines": [1, 2, 3],
                "missing_lines": [5],
                "summary": {"covered_lines": 3, "num_statements": 4, "percent_covered": 75.0}
            }
        },
        "totals": {"covered_lines": 3, "num_statements": 4, "percent_covered": 75.0}
    }"#;

    let result = parse_coverage_json(json, Duration::ZERO);
    assert!(result.success);
    assert_eq!(result.line_coverage, Some(75.0));
    assert_eq!(result.files.len(), 1);
}

#[test]
fn parses_cobertura_xml() {
    let xml = r#"<?xml version="1.0" ?>
        <coverage version="7.4.0" line-rate="0.75">
            <packages>
                <package name="myproject">
                    <classes>
                        <class name="math.py" filename="src/myproject/math.py" line-rate="0.75">
                            <lines><line number="1" hits="1"/></lines>
                        </class>
                    </classes>
                </package>
            </packages>
        </coverage>"#;

    let result = parse_cobertura_xml(xml, Duration::ZERO);
    assert!(result.success);
    assert_eq!(result.line_coverage, Some(75.0));
}

#[test]
fn normalizes_python_paths() {
    assert_eq!(normalize_python_path("/home/user/project/src/myproject/math.py"), "src/myproject/math.py");
    assert_eq!(normalize_python_path("/project/myproject/utils.py"), "myproject/utils.py");
}

#[test]
fn extracts_python_package() {
    assert_eq!(extract_python_package("src/myproject/math.py"), "myproject");
    assert_eq!(extract_python_package("myproject/utils.py"), "myproject");
    assert_eq!(extract_python_package("tests/test_math.py"), "tests");
}
```

## Key Implementation Details

### Coverage Tool Priority

1. **pytest-cov** (preferred): Single command, integrated output
   - Command: `pytest --cov=src --cov-report=json`
   - Output: `coverage.json` in project root

2. **coverage.py**: Standard library compatible
   - Command: `coverage run -m pytest && coverage json`
   - Output: `coverage.json` or `.coverage` SQLite

### Report Format Priority

1. `coverage.json` - Easiest to parse, most complete data
2. `coverage.xml` (Cobertura) - Widely supported, XML parsing
3. `.coverage` (SQLite) - Requires sqlite3, more complex

### Path Normalization

Python coverage reports absolute paths. Normalize to project-relative:

```rust
fn normalize_python_path(path: &str) -> String {
    // Look for src-layout: src/<package>/
    if let Some(idx) = path.find("/src/") {
        return path[idx + 1..].to_string();
    }
    // Look for flat-layout: <package>/
    for marker in ["myproject/", "app/", "lib/"] {
        if let Some(idx) = path.find(marker) {
            return path[idx..].to_string();
        }
    }
    // Fallback: filename only
    Path::new(path).file_name().unwrap_or_default().to_string_lossy().to_string()
}
```

### Package Extraction

Extract Python package name for per-package metrics:

```rust
fn extract_python_package(path: &str) -> String {
    // src-layout: src/<package>/... -> <package>
    if let Some(rest) = path.strip_prefix("src/") {
        if let Some(end) = rest.find('/') {
            return rest[..end].to_string();
        }
    }
    // flat-layout: <package>/... -> <package>
    if let Some(end) = path.find('/') {
        return path[..end].to_string();
    }
    "root".to_string()
}
```

### Branch Coverage (Optional)

coverage.py supports branch coverage. When enabled, include in metrics:

```rust
pub struct CoverageResult {
    // ... existing fields ...
    /// Branch coverage percentage (0-100), if available.
    pub branch_coverage: Option<f64>,
}
```

For Phase 1, focus on line coverage. Branch coverage can be added in future iteration.

## Verification Plan

### Phase 1 Verification
- [ ] `coverage_available()` returns true when coverage.py installed
- [ ] `pytest_cov_available()` returns true when pytest-cov installed
- [ ] Unit test: `parses_coverage_json` passes

### Phase 2 Verification
- [ ] Unit test: JSON parser handles complete coverage.json
- [ ] Unit test: JSON parser handles minimal coverage.json
- [ ] Unit test: JSON parser returns error for invalid JSON

### Phase 3 Verification
- [ ] Unit test: XML parser handles complete Cobertura XML
- [ ] Unit test: XML parser handles minimal XML
- [ ] Unit test: XML parser returns error for invalid XML

### Phase 4 Verification
- [ ] Pytest runner collects coverage when `ctx.collect_coverage = true`
- [ ] Coverage data appears in `TestRunResult.coverage`
- [ ] Coverage skipped when `ctx.collect_coverage = false`

### Phase 5 Verification
- [ ] `AggregatedCoverage.merge_python()` works correctly
- [ ] `to_coverage_map()` includes Python coverage
- [ ] Coverage appears in check metrics JSON

### Phase 6 Verification
- [ ] Test fixture runs with `quench check --ci`
- [ ] Coverage metrics appear in output
- [ ] All unit tests pass with `cargo test`

### Integration Verification
- [ ] `quench check --ci --tests` on `python/coverage-simple` shows coverage
- [ ] Coverage percentage matches actual test coverage
- [ ] Per-package coverage extracted correctly
- [ ] Multiple test suites aggregate coverage correctly

## Checklist

- [ ] Create `python_coverage.rs` with JSON/XML parsers
- [ ] Create `python_coverage_tests.rs` with unit tests
- [ ] Update `mod.rs` with module and aggregation
- [ ] Modify `pytest.rs` to collect coverage
- [ ] Create `tests/fixtures/python/coverage-simple/`
- [ ] Bump `CACHE_VERSION` in `crates/cli/src/cache.rs`
- [ ] Run `make check` passes
