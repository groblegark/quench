# Phase 449: Python Profile Defaults

## Overview

Add Python language profile support to `quench init`. This enables auto-detection of Python projects and generates appropriate configuration with Python-specific escape patterns, suppress settings, and lint policy defaults.

## Project Structure

Files to modify/create:

```
crates/cli/src/
├── init.rs            # Add DetectedLanguage::Python, detection logic
├── init_tests.rs      # Unit tests for Python detection
├── profiles.rs        # Add python_profile_defaults(), landing items, registry
└── profiles_tests.rs  # Unit tests for Python profile

tests/specs/cli/
└── init.rs            # Behavioral specs for Python init
```

## Dependencies

- **Blocked by**: Phase 1505-1510 (Init Command - Profile Detection/Config Generation) - Already complete
- **No external dependencies**: Uses existing init and profiles infrastructure

## Implementation Phases

### Phase 1: Add Python to DetectedLanguage enum

Add the Python variant to `DetectedLanguage` in `init.rs`:

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum DetectedLanguage {
    Rust,
    Golang,
    JavaScript,
    Shell,
    Ruby,
    Python,  // Add this
}
```

**Verification**: Code compiles with `cargo check`

### Phase 2: Implement Python detection logic

Add detection in `detect_languages()` for Python markers:

```rust
// Python: pyproject.toml, setup.py, setup.cfg, or requirements.txt exists
if root.join("pyproject.toml").exists()
    || root.join("setup.py").exists()
    || root.join("setup.cfg").exists()
    || root.join("requirements.txt").exists()
{
    languages.push(DetectedLanguage::Python);
}
```

Detection priority (per `.5-roadmap-python.md`):
1. `pyproject.toml` - Modern Python projects
2. `setup.py` - Traditional setuptools projects
3. `setup.cfg` - Declarative setuptools config
4. `requirements.txt` - Fallback for simple projects

**Verification**: Unit tests in `init_tests.rs` pass

### Phase 3: Create Python profile defaults

Add to `profiles.rs`:

```rust
/// Python profile configuration for quench init.
pub fn python_profile_defaults() -> String {
    r##"[python]
source = ["**/*.py"]
tests = ["tests/**/*.py", "test/**/*.py", "test_*.py", "*_test.py", "conftest.py"]

[python.suppress]
check = "comment"

[python.suppress.test]
check = "allow"

[python.policy]
lint_changes = "standalone"
lint_config = ["pyproject.toml", "ruff.toml", ".ruff.toml", ".flake8", ".pylintrc", "pylintrc", "mypy.ini", ".mypy.ini", "setup.cfg"]

[[check.escapes.patterns]]
name = "eval"
pattern = "\\beval\\("
action = "comment"
comment = "# EVAL:"
advice = "Add a # EVAL: comment explaining why eval is necessary."

[[check.escapes.patterns]]
name = "exec"
pattern = "\\bexec\\("
action = "comment"
comment = "# EXEC:"
advice = "Add a # EXEC: comment explaining why exec is necessary."

[[check.escapes.patterns]]
name = "dynamic_import"
pattern = "__import__\\("
action = "comment"
comment = "# DYNAMIC:"
advice = "Add a # DYNAMIC: comment explaining the dynamic import."

[[check.escapes.patterns]]
name = "breakpoint"
pattern = "\\bbreakpoint\\("
action = "forbid"
in_tests = "allow"
advice = "Remove breakpoint() before committing."

[[check.escapes.patterns]]
name = "pdb_trace"
pattern = "pdb\\.set_trace\\("
action = "forbid"
in_tests = "allow"
advice = "Remove pdb.set_trace() before committing."

[[check.escapes.patterns]]
name = "import_pdb"
pattern = "^import pdb$"
action = "forbid"
in_tests = "allow"
advice = "Remove pdb import before committing."
"##
    .to_string()
}
```

**Verification**: Unit tests in `profiles_tests.rs` pass

### Phase 4: Add Python to ProfileRegistry

Update `ProfileRegistry` in `profiles.rs`:

```rust
impl ProfileRegistry {
    pub fn available() -> &'static [&'static str] {
        &[
            "rust",
            "golang",
            "javascript",
            "ruby",
            "python",  // Add this
            "shell",
            "claude",
            "cursor",
        ]
    }

    pub fn get(name: &str) -> Option<String> {
        match name.to_lowercase().as_str() {
            "rust" => Some(rust_profile_defaults()),
            "shell" => Some(shell_profile_defaults()),
            "golang" | "go" => Some(golang_profile_defaults()),
            "javascript" | "js" | "typescript" | "ts" => Some(javascript_profile_defaults()),
            "ruby" | "rb" => Some(ruby_profile_defaults()),
            "python" | "py" => Some(python_profile_defaults()),  // Add this
            "claude" => Some(claude_profile_defaults().to_string()),
            "cursor" => Some(cursor_profile_defaults().to_string()),
            _ => None,
        }
    }

    pub fn suggest(name: &str) -> Option<&'static str> {
        // Add to aliases section:
        match lower.as_str() {
            // ... existing ...
            "py" | "pip" | "poetry" | "uv" | "django" | "flask" | "fastapi" => Some("python"),
            _ => None,
        }
    }
}
```

**Verification**: `ProfileRegistry::get("python")` and `ProfileRegistry::get("py")` return profile

### Phase 5: Add Python detected section and landing items

Add minimal detection section for auto-detection output:

```rust
/// Minimal Python section for auto-detection output.
pub fn python_detected_section() -> &'static str {
    r#"[python]
python.cloc.check = "error"
python.policy.check = "error"
python.suppress.check = "comment"
"#
}

/// Python-specific Landing the Plane checklist items.
pub fn python_landing_items() -> &'static [&'static str] {
    &[
        "ruff check .",
        "ruff format --check .",
        "mypy .",
        "pytest",
    ]
}
```

**Verification**: Functions exist and return expected content

### Phase 6: Write unit tests

Add to `init_tests.rs`:

```rust
// =============================================================================
// Python Detection Tests
// =============================================================================

#[test]
fn detect_python_from_pyproject_toml() {
    let temp = TempDir::new().unwrap();
    fs::write(temp.path().join("pyproject.toml"), "[project]\nname = \"test\"").unwrap();

    let detected = detect_languages(temp.path());
    assert!(detected.contains(&DetectedLanguage::Python));
}

#[test]
fn detect_python_from_setup_py() {
    let temp = TempDir::new().unwrap();
    fs::write(temp.path().join("setup.py"), "from setuptools import setup").unwrap();

    let detected = detect_languages(temp.path());
    assert!(detected.contains(&DetectedLanguage::Python));
}

#[test]
fn detect_python_from_setup_cfg() {
    let temp = TempDir::new().unwrap();
    fs::write(temp.path().join("setup.cfg"), "[metadata]\nname = test").unwrap();

    let detected = detect_languages(temp.path());
    assert!(detected.contains(&DetectedLanguage::Python));
}

#[test]
fn detect_python_from_requirements_txt() {
    let temp = TempDir::new().unwrap();
    fs::write(temp.path().join("requirements.txt"), "requests==2.28.0").unwrap();

    let detected = detect_languages(temp.path());
    assert!(detected.contains(&DetectedLanguage::Python));
}
```

Add to `profiles_tests.rs`:

```rust
#[test]
fn profile_registry_includes_python() {
    let available = ProfileRegistry::available();
    assert!(available.contains(&"python"));
}

#[test]
fn profile_registry_get_python() {
    let profile = ProfileRegistry::get("python");
    assert!(profile.is_some());

    let profile = profile.unwrap();
    assert!(profile.contains("[python]"));
    assert!(profile.contains("[python.suppress]"));
    assert!(profile.contains("[python.policy]"));
}

#[test]
fn profile_registry_python_aliases_work() {
    assert!(ProfileRegistry::get("py").is_some());
}

#[test]
fn python_profile_has_escape_patterns() {
    let profile = python_profile_defaults();
    assert!(profile.contains("eval"));
    assert!(profile.contains("exec"));
    assert!(profile.contains("breakpoint"));
    assert!(profile.contains("# EVAL:"));
}
```

**Verification**: `cargo test` passes

### Phase 7: Write behavioral specs

Add to `tests/specs/cli/init.rs`:

```rust
// =============================================================================
// Python Profile and Detection Specs
// =============================================================================

/// Spec: docs/specs/langs/python.md#profile-defaults
///
/// > --with python configures Python defaults
#[test]
fn init_with_python_configures_python_defaults() {
    let temp = Project::empty();

    quench_cmd()
        .args(["init", "--with", "python"])
        .current_dir(temp.path())
        .assert()
        .success()
        .stdout(predicates::str::contains("python"));

    let config = std::fs::read_to_string(temp.path().join("quench.toml")).unwrap();
    assert!(config.contains("[python]"));
    assert!(config.contains("[python.suppress]"));
    assert!(config.contains("[python.policy]"));
    assert!(config.contains("eval"), "should have eval escape pattern");
}

/// Spec: docs/specs/langs/python.md#detection
///
/// > Auto-detects Python from pyproject.toml
#[test]
fn init_auto_detects_python_from_pyproject_toml() {
    let temp = Project::empty();
    temp.file("pyproject.toml", "[project]\nname = \"test\"\n");

    quench_cmd()
        .args(["init"])
        .current_dir(temp.path())
        .assert()
        .success();

    let config = std::fs::read_to_string(temp.path().join("quench.toml")).unwrap();
    assert!(config.contains("[python]"));
}

/// Spec: docs/specs/langs/python.md#detection
///
/// > Auto-detects Python from setup.py
#[test]
fn init_auto_detects_python_from_setup_py() {
    let temp = Project::empty();
    temp.file("setup.py", "from setuptools import setup\n");

    quench_cmd()
        .args(["init"])
        .current_dir(temp.path())
        .assert()
        .success();

    let config = std::fs::read_to_string(temp.path().join("quench.toml")).unwrap();
    assert!(config.contains("[python]"));
}

/// Spec: docs/specs/langs/python.md#detection
///
/// > Auto-detects Python from requirements.txt
#[test]
fn init_auto_detects_python_from_requirements_txt() {
    let temp = Project::empty();
    temp.file("requirements.txt", "requests>=2.28.0\n");

    quench_cmd()
        .args(["init"])
        .current_dir(temp.path())
        .assert()
        .success();

    let config = std::fs::read_to_string(temp.path().join("quench.toml")).unwrap();
    assert!(config.contains("[python]"));
}

/// Spec: docs/specs/01-cli.md#explicit-profiles
///
/// > --with py is an alias for python
#[test]
fn init_with_py_alias() {
    let temp = Project::empty();

    quench_cmd()
        .args(["init", "--with", "py"])
        .current_dir(temp.path())
        .assert()
        .success();

    let config = std::fs::read_to_string(temp.path().join("quench.toml")).unwrap();
    assert!(config.contains("[python]"));
}

/// Spec: docs/specs/langs/python.md#profile-defaults
///
/// > Python profile includes escape patterns for debuggers
#[test]
fn init_python_profile_includes_debugger_patterns() {
    let temp = Project::empty();

    quench_cmd()
        .args(["init", "--with", "python"])
        .current_dir(temp.path())
        .assert()
        .success();

    let config = std::fs::read_to_string(temp.path().join("quench.toml")).unwrap();
    assert!(
        config.contains("breakpoint"),
        "config should have breakpoint escape pattern"
    );
    assert!(
        config.contains("pdb"),
        "config should have pdb escape pattern"
    );
    assert!(
        config.contains("# EVAL:"),
        "config should have # EVAL: comment marker"
    );
}
```

**Verification**: `cargo test --test specs` passes

## Key Implementation Details

### Escape Patterns

Python-specific escape patterns follow the roadmap:

| Pattern | Action | Comment Required |
|---------|--------|------------------|
| `eval(` | comment | `# EVAL:` |
| `exec(` | comment | `# EXEC:` |
| `__import__(` | comment | `# DYNAMIC:` |
| `breakpoint()` | forbid (allow in tests) | N/A |
| `pdb.set_trace()` | forbid (allow in tests) | N/A |
| `import pdb` | forbid (allow in tests) | N/A |

### Suppress Policy

- Source files: `check = "comment"` (suppressions like `# noqa` require explanation)
- Test files: `check = "allow"` (suppressions allowed without explanation)

### Lint Config Detection

Python has a fragmented linter ecosystem. Config files to detect:
- `pyproject.toml` (Ruff, Black, Mypy, Pylint sections)
- `ruff.toml`, `.ruff.toml`
- `.flake8`
- `.pylintrc`, `pylintrc`
- `mypy.ini`, `.mypy.ini`
- `setup.cfg` (legacy flake8/mypy sections)

### Integration with init command

The init command needs to be updated to:
1. Call `python_detected_section()` when Python is auto-detected
2. Handle `--with python` and `--with py` via `ProfileRegistry`

This requires updating the init command dispatch logic (likely in `crates/cli/src/commands/init.rs` or similar) to map `DetectedLanguage::Python` to the appropriate section generator.

## Verification Plan

1. **Unit tests**: `cargo test -p quench-cli init python`
   - Python detection from all marker files
   - Profile content includes expected sections

2. **Integration tests**: `cargo test --test specs -- python`
   - `quench init --with python` creates valid config
   - `quench init` auto-detects Python projects
   - `--with py` alias works

3. **Manual verification**:
   ```bash
   mkdir -p /tmp/py-test && cd /tmp/py-test
   echo '[project]\nname = "test"' > pyproject.toml
   quench init
   cat quench.toml  # Should contain [python] section

   rm quench.toml
   quench init --with python
   cat quench.toml  # Should contain full Python defaults
   ```

4. **Full test suite**: `make check`
   - All existing tests still pass
   - No regressions in other profiles/detection
