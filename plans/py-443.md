# Phase 443: Python Adapter - Detection

## Overview

Add Python language detection to quench, enabling auto-detection of Python projects
and classification of Python source and test files. This phase implements the detection
layer without escape patterns (Phase 445) or suppress patterns (Phase 446).

## Project Structure

New and modified files:

```
crates/cli/src/
├── adapter/
│   ├── mod.rs                    # Add Python to detection, registry
│   ├── patterns.rs               # Add LanguageDefaults impl for PythonConfig
│   └── python/
│       ├── mod.rs                # PythonAdapter struct + Adapter trait impl
│       └── mod_tests.rs          # Unit tests for classification
├── config/
│   ├── mod.rs                    # Add python field to Config struct
│   └── python.rs                 # PythonConfig, PythonDefaults

tests/
├── fixtures/python/
│   ├── auto-detect-pyproject/    # pyproject.toml detection
│   ├── auto-detect-setup-py/     # setup.py fallback
│   ├── auto-detect-requirements/ # requirements.txt fallback
│   ├── src-layout/               # src/package_name/ structure
│   ├── flat-layout/              # package_name/ structure
│   └── venv-ignore/              # .venv/ ignored
└── specs/adapters/
    ├── mod.rs                    # Add python module
    └── python.rs                 # Behavioral specs
```

## Dependencies

- External: `toml` crate (already in dependencies for config parsing)
- Internal: Phase 201 (Generic Language Adapter) - completed

## Implementation Phases

### Phase 1: Configuration Module

Create `crates/cli/src/config/python.rs` following the Go pattern.

**Files:**
- `crates/cli/src/config/python.rs` - New
- `crates/cli/src/config/mod.rs` - Add `python` field and imports

**Key Implementation:**

```rust
// crates/cli/src/config/python.rs

use serde::Deserialize;
use super::lang_common::{LanguageDefaults, define_policy_config};
use super::{CheckLevel, LangClocConfig, LintChangesPolicy, SuppressLevel, SuppressScopeConfig};

/// Python language-specific configuration.
#[derive(Debug, Clone, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct PythonConfig {
    /// Source file patterns.
    #[serde(default = "PythonDefaults::default_source")]
    pub source: Vec<String>,

    /// Test file patterns.
    #[serde(default = "PythonDefaults::default_tests")]
    pub tests: Vec<String>,

    /// Ignore patterns.
    #[serde(default = "PythonDefaults::default_ignore")]
    pub ignore: Vec<String>,

    /// Per-language cloc settings.
    #[serde(default)]
    pub cloc: Option<LangClocConfig>,

    /// Custom cloc advice.
    #[serde(default)]
    pub cloc_advice: Option<String>,
}

pub struct PythonDefaults;

impl LanguageDefaults for PythonDefaults {
    fn default_source() -> Vec<String> {
        vec!["**/*.py".to_string()]
    }

    fn default_tests() -> Vec<String> {
        vec![
            "tests/**/*.py".to_string(),
            "**/test_*.py".to_string(),
            "**/*_test.py".to_string(),
            "**/conftest.py".to_string(),
        ]
    }

    fn default_ignore() -> Vec<String> {
        vec![
            ".venv/**".to_string(),
            "venv/**".to_string(),
            "__pycache__/**".to_string(),
            ".mypy_cache/**".to_string(),
            ".pytest_cache/**".to_string(),
            "dist/**".to_string(),
            "build/**".to_string(),
            "*.egg-info/**".to_string(),
            ".tox/**".to_string(),
            ".nox/**".to_string(),
        ]
    }

    fn default_cloc_advice() -> &'static str {
        "Can the code be made more concise?\n\n\
         Look for repetitive patterns that could be extracted into helper functions.\n\n\
         If not, split large modules into submodules using packages (directories with __init__.py).\n\n\
         Avoid picking and removing individual lines to satisfy the linter,\n\
         prefer properly refactoring out testable code blocks."
    }
}
```

**Verification:**
- `cargo check` compiles
- Config parses `[python]` section in quench.toml

---

### Phase 2: Python Adapter Core

Create the adapter module with file classification.

**Files:**
- `crates/cli/src/adapter/python/mod.rs` - New
- `crates/cli/src/adapter/python/mod_tests.rs` - New
- `crates/cli/src/adapter/mod.rs` - Add Python module and detection

**Key Implementation:**

```rust
// crates/cli/src/adapter/python/mod.rs

use std::path::Path;
use globset::GlobSet;

use super::glob::build_glob_set;
use super::{Adapter, EscapePattern, FileKind};

/// Python language adapter.
pub struct PythonAdapter {
    source_patterns: GlobSet,
    test_patterns: GlobSet,
    ignore_patterns: GlobSet,
}

impl PythonAdapter {
    pub fn new() -> Self {
        Self {
            source_patterns: build_glob_set(&["**/*.py".to_string()]),
            test_patterns: build_glob_set(&[
                "tests/**/*.py".to_string(),
                "**/test_*.py".to_string(),
                "**/*_test.py".to_string(),
                "**/conftest.py".to_string(),
            ]),
            ignore_patterns: build_glob_set(&[
                ".venv/**".to_string(),
                "venv/**".to_string(),
                "__pycache__/**".to_string(),
                ".mypy_cache/**".to_string(),
                ".pytest_cache/**".to_string(),
                "dist/**".to_string(),
                "build/**".to_string(),
                "*.egg-info/**".to_string(),
                ".tox/**".to_string(),
                ".nox/**".to_string(),
            ]),
        }
    }

    pub fn with_patterns(patterns: super::ResolvedPatterns) -> Self {
        Self {
            source_patterns: build_glob_set(&patterns.source),
            test_patterns: build_glob_set(&patterns.test),
            ignore_patterns: build_glob_set(&patterns.ignore),
        }
    }

    pub fn should_ignore(&self, path: &Path) -> bool {
        self.ignore_patterns.is_match(path)
    }
}

impl Adapter for PythonAdapter {
    fn name(&self) -> &'static str {
        "python"
    }

    fn extensions(&self) -> &'static [&'static str] {
        &["py"]
    }

    fn classify(&self, path: &Path) -> FileKind {
        if self.should_ignore(path) {
            return FileKind::Other;
        }
        if self.test_patterns.is_match(path) {
            return FileKind::Test;
        }
        if self.source_patterns.is_match(path) {
            return FileKind::Source;
        }
        FileKind::Other
    }

    fn default_escapes(&self) -> &'static [EscapePattern] {
        &[] // Phase 445 will add escape patterns
    }
}
```

**Detection in mod.rs:**

```rust
// Add to ProjectLanguage enum
pub enum ProjectLanguage {
    Rust,
    Go,
    JavaScript,
    Ruby,
    Python,  // NEW
    Shell,
    Generic,
}

// Add to detect_language()
pub fn detect_language(root: &Path) -> ProjectLanguage {
    // ... existing checks ...

    // Python detection (before Shell)
    if has_python_markers(root) {
        return ProjectLanguage::Python;
    }

    // ... rest ...
}

/// Check if project has Python markers.
fn has_python_markers(root: &Path) -> bool {
    root.join("pyproject.toml").exists()
        || root.join("setup.py").exists()
        || root.join("setup.cfg").exists()
        || root.join("requirements.txt").exists()
}
```

**Verification:**
- Unit tests pass for file classification
- `cargo test adapter::python`

---

### Phase 3: Package Name Extraction

Implement parsing of pyproject.toml and setup.py to extract package names.

**Files:**
- `crates/cli/src/adapter/python/mod.rs` - Add parsing functions

**Key Implementation:**

```rust
/// Parse pyproject.toml to extract project name.
/// Looks for [project].name per PEP 621.
pub fn parse_pyproject_toml(content: &str) -> Option<String> {
    let table: toml::Table = content.parse().ok()?;
    table
        .get("project")?
        .get("name")?
        .as_str()
        .map(|s| s.to_string())
}

/// Parse setup.py to extract package name.
/// Uses regex to find name="..." or name='...' argument.
pub fn parse_setup_py(content: &str) -> Option<String> {
    // Match: name="package" or name='package' or name = "package"
    let re = regex::Regex::new(r#"name\s*=\s*["']([^"']+)["']"#).ok()?;
    re.captures(content)
        .and_then(|c| c.get(1))
        .map(|m| m.as_str().to_string())
}
```

**Verification:**
- Unit tests for parsing various pyproject.toml formats
- Unit tests for parsing setup.py with different styles

---

### Phase 4: Layout Detection

Detect src-layout vs flat-layout project structures.

**Files:**
- `crates/cli/src/adapter/python/mod.rs` - Add layout detection

**Key Implementation:**

```rust
/// Project layout type.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PythonLayout {
    /// src/package_name/ structure (PEP 517 recommended)
    SrcLayout,
    /// package_name/ in root (traditional)
    FlatLayout,
    /// No detectable layout
    Unknown,
}

/// Detect Python project layout.
pub fn detect_layout(root: &Path, package_name: Option<&str>) -> PythonLayout {
    // Check for src-layout first (recommended)
    let src_dir = root.join("src");
    if src_dir.is_dir() {
        // If we have a package name, verify it exists under src/
        if let Some(name) = package_name {
            let pkg_dir = src_dir.join(name.replace('-', "_"));
            if pkg_dir.join("__init__.py").exists() || pkg_dir.is_dir() {
                return PythonLayout::SrcLayout;
            }
        }
        // Otherwise, check if any package exists under src/
        if has_python_package(&src_dir) {
            return PythonLayout::SrcLayout;
        }
    }

    // Check for flat-layout
    if let Some(name) = package_name {
        let pkg_dir = root.join(name.replace('-', "_"));
        if pkg_dir.join("__init__.py").exists() {
            return PythonLayout::FlatLayout;
        }
    }

    // Check if root has any Python package
    if has_python_package(root) {
        return PythonLayout::FlatLayout;
    }

    PythonLayout::Unknown
}

fn has_python_package(dir: &Path) -> bool {
    dir.read_dir()
        .ok()
        .map(|entries| {
            entries.filter_map(|e| e.ok()).any(|entry| {
                let path = entry.path();
                path.is_dir() && path.join("__init__.py").exists()
            })
        })
        .unwrap_or(false)
}
```

**Verification:**
- Unit tests for src-layout detection
- Unit tests for flat-layout detection
- Unit tests for unknown layout

---

### Phase 5: Test Fixtures

Create test fixtures for behavioral specs.

**Fixtures:**

```
tests/fixtures/python/
├── auto-detect-pyproject/
│   ├── pyproject.toml         # [project]\nname = "myproject"
│   ├── quench.toml            # version = 1
│   ├── src/
│   │   └── myproject/
│   │       ├── __init__.py
│   │       └── main.py        # def main(): pass
│   └── tests/
│       └── test_main.py       # def test_main(): pass

├── auto-detect-setup-py/
│   ├── setup.py               # name="legacyproject"
│   ├── quench.toml
│   ├── legacyproject/
│   │   ├── __init__.py
│   │   └── core.py
│   └── tests/
│       └── test_core.py

├── auto-detect-requirements/
│   ├── requirements.txt       # requests>=2.0
│   ├── quench.toml
│   ├── app.py
│   └── test_app.py

├── src-layout/
│   ├── pyproject.toml
│   ├── quench.toml
│   ├── src/
│   │   └── mypackage/
│   │       ├── __init__.py
│   │       └── lib.py
│   └── tests/
│       └── test_lib.py

├── flat-layout/
│   ├── pyproject.toml
│   ├── quench.toml
│   ├── mypackage/
│   │   ├── __init__.py
│   │   └── lib.py
│   └── tests/
│       └── test_lib.py

└── venv-ignore/
    ├── pyproject.toml
    ├── quench.toml
    ├── src/
    │   └── myproject/
    │       └── __init__.py
    └── .venv/
        └── lib/
            └── site.py        # Should be ignored
```

**Verification:**
- Fixtures compile and are accessible
- `ls tests/fixtures/python/` shows expected structure

---

### Phase 6: Behavioral Specs

Create behavioral tests following the spec template.

**Files:**
- `tests/specs/adapters/python.rs` - New
- `tests/specs/adapters/mod.rs` - Add `mod python;`

**Key Specs:**

```rust
// tests/specs/adapters/python.rs

//! Behavioral specs for the Python language adapter.

#![allow(clippy::unwrap_used, clippy::expect_used)]

use crate::prelude::*;

// =============================================================================
// AUTO-DETECTION SPECS
// =============================================================================

/// Spec: plans/.5-roadmap-python.md#phase-443
///
/// > pyproject.toml detection
#[test]
fn auto_detected_when_pyproject_toml_present() {
    let result = cli().on("python/auto-detect-pyproject").json().passes();
    let checks = result.checks();
    assert!(checks.iter().any(|c|
        c.get("name").and_then(|n| n.as_str()) == Some("cloc")
    ));
}

/// Spec: plans/.5-roadmap-python.md#phase-443
///
/// > setup.py detection
#[test]
fn auto_detected_when_setup_py_present() {
    let result = cli().on("python/auto-detect-setup-py").json().passes();
    let checks = result.checks();
    assert!(checks.iter().any(|c|
        c.get("name").and_then(|n| n.as_str()) == Some("cloc")
    ));
}

/// Spec: plans/.5-roadmap-python.md#phase-443
///
/// > requirements.txt detection (fallback)
#[test]
fn auto_detected_when_requirements_txt_present() {
    let result = cli().on("python/auto-detect-requirements").json().passes();
    let checks = result.checks();
    assert!(checks.iter().any(|c|
        c.get("name").and_then(|n| n.as_str()) == Some("cloc")
    ));
}

// =============================================================================
// DEFAULT PATTERN SPECS
// =============================================================================

/// Spec: plans/.5-roadmap-python.md#phase-443
///
/// > Default source patterns (**/*.py)
#[test]
fn default_source_pattern_matches_py_files() {
    let cloc = check("cloc").on("python/auto-detect-pyproject").json().passes();
    let metrics = cloc.require("metrics");
    let source_lines = metrics.get("source_lines")
        .and_then(|v| v.as_u64()).unwrap_or(0);
    assert!(source_lines > 0, "should count .py files as source");
}

/// Spec: plans/.5-roadmap-python.md#phase-443
///
/// > Default test patterns (tests/**/*.py, test_*.py, *_test.py, conftest.py)
#[test]
fn default_test_pattern_matches_test_files() {
    let cloc = check("cloc").on("python/auto-detect-pyproject").json().passes();
    let metrics = cloc.require("metrics");
    let test_lines = metrics.get("test_lines")
        .and_then(|v| v.as_u64()).unwrap_or(0);
    assert!(test_lines > 0, "should count test_*.py files as test");
}

/// Spec: plans/.5-roadmap-python.md#phase-443
///
/// > Default ignores (.venv/, __pycache__/, etc.)
#[test]
fn default_ignores_venv_directory() {
    let cloc = check("cloc").on("python/venv-ignore").json().passes();
    let metrics = cloc.require("metrics");
    let source_lines = metrics.get("source_lines")
        .and_then(|v| v.as_u64()).unwrap_or(0);
    // Only src/myproject/__init__.py should be counted, not .venv/lib/site.py
    assert!(source_lines < 20, ".venv/ should be ignored");
}

// =============================================================================
// LAYOUT DETECTION SPECS
// =============================================================================

/// Spec: plans/.5-roadmap-python.md#phase-443
///
/// > Src-layout detection (src/package_name/)
#[test]
fn detects_src_layout_structure() {
    let cloc = check("cloc").on("python/src-layout").json().passes();
    let metrics = cloc.require("metrics");
    let source_lines = metrics.get("source_lines")
        .and_then(|v| v.as_u64()).unwrap_or(0);
    assert!(source_lines > 0, "should detect src-layout");
}

/// Spec: plans/.5-roadmap-python.md#phase-443
///
/// > Flat-layout detection (package_name/)
#[test]
fn detects_flat_layout_structure() {
    let cloc = check("cloc").on("python/flat-layout").json().passes();
    let metrics = cloc.require("metrics");
    let source_lines = metrics.get("source_lines")
        .and_then(|v| v.as_u64()).unwrap_or(0);
    assert!(source_lines > 0, "should detect flat-layout");
}
```

**Verification:**
- `cargo test --test specs adapters::python`

---

## Key Implementation Details

### Detection Priority

Python detection should occur after JavaScript/Ruby but before Shell:

```rust
pub fn detect_language(root: &Path) -> ProjectLanguage {
    if root.join("Cargo.toml").exists() { return Rust; }
    if root.join("go.mod").exists() { return Go; }
    if has_js_markers(root) { return JavaScript; }
    if has_ruby_markers(root) { return Ruby; }
    if has_python_markers(root) { return Python; }  // NEW
    if has_shell_markers(root) { return Shell; }
    Generic
}
```

### Marker File Priority

For Python detection, check files in this order (first match wins):
1. `pyproject.toml` - Modern Python (PEP 517/518/621)
2. `setup.py` - Traditional setuptools
3. `setup.cfg` - Declarative setuptools
4. `requirements.txt` - Dependency file fallback

### Test Pattern Subtleties

The test patterns must handle pytest conventions:
- `tests/**/*.py` - Standard tests directory
- `**/test_*.py` - pytest's default test file pattern
- `**/*_test.py` - Alternative suffix pattern
- `**/conftest.py` - pytest fixtures (always test code)

### Package Name Normalization

Python package names may contain hyphens, but directory names use underscores:
- Package name: `my-package`
- Directory: `my_package/`

Use `name.replace('-', "_")` when mapping to filesystem.

### Config Integration

Add to `Config` struct in mod.rs:

```rust
/// Python-specific configuration.
#[serde(default)]
pub python: PythonConfig,
```

Add to pattern resolution:

```rust
/// Resolve Python patterns from config.
fn resolve_python_patterns(
    config: &crate::config::Config,
    fallback_test: &[String],
) -> ResolvedPatterns {
    patterns::resolve_patterns::<crate::config::PythonConfig>(
        &config.python.source,
        &config.python.tests,
        &config.python.ignore,
        fallback_test,
    )
}
```

## Verification Plan

### Unit Tests (`cargo test`)

1. **Config parsing**: `config::python` parses `[python]` sections
2. **File classification**: `adapter::python` classifies files correctly
3. **pyproject.toml parsing**: Extracts `[project].name`
4. **setup.py parsing**: Extracts `name="..."` argument
5. **Layout detection**: Identifies src-layout vs flat-layout

### Integration Tests (`cargo test --test specs`)

1. **Auto-detection**: Python detected via pyproject.toml, setup.py, requirements.txt
2. **Source patterns**: `.py` files counted as source
3. **Test patterns**: `test_*.py` files counted as test
4. **Ignore patterns**: `.venv/` not counted
5. **Layout handling**: Both layouts produce valid metrics

### Manual Verification

```bash
# Test on real Python project
cd /path/to/python-project
quench check --json | jq '.checks[] | select(.name == "cloc")'

# Verify source/test split
quench check cloc --verbose
```

## Future Work (Not in Scope)

These are deferred to later phases:

- **Phase 445**: Escape patterns (`eval(`, `exec(`, `__import__(`, etc.)
- **Phase 446**: Suppress patterns (`# noqa`, `# type: ignore`, etc.)
- **Phase 447**: Lint policy (ruff.toml, .flake8, etc.)
- **Phase 448**: Test runners (pytest, unittest)
- **Phase 449**: Init profiles
