# Phase 4491: Python Landing the Plane

## Overview

Add Python-specific Landing the Plane checklist items to quench. This includes:
- Python package manager detection (pip, poetry, uv, pipenv)
- Conditional tool inclusion based on config file presence
- Landing items that adapt to the detected tooling environment

## Project Structure

Files to modify/create:

```
crates/cli/src/
├── adapter/python/
│   ├── mod.rs              # Add package_manager module export
│   ├── package_manager.rs  # NEW: Python package manager detection
│   └── package_manager_tests.rs  # NEW: Unit tests
├── profiles.rs             # Add python_landing_items(), python_landing_items_for()
├── profiles_tests.rs       # Add tests for Python landing items
└── cli.rs                  # Export python_landing_items functions

tests/specs/cli/
└── init.rs                 # Add behavioral specs for Python landing items
```

## Dependencies

- **Blocked by**: Phase 449 (Python Profile Defaults) - Ensures Python profile infrastructure exists
- **No external dependencies**: Uses existing init and profiles infrastructure

## Implementation Phases

### Phase 1: Create Python Package Manager Detection

Create `crates/cli/src/adapter/python/package_manager.rs`:

```rust
//! Python package manager detection.
//!
//! Detects package manager from lock files and provides command generation.
//! Detection order (first match wins):
//! 1. `uv.lock` (uv)
//! 2. `poetry.lock` (Poetry)
//! 3. `Pipfile.lock` / `Pipfile` (pipenv)
//! 4. `requirements.txt` or `pyproject.toml` (pip)

use std::path::Path;

/// Python package manager.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum PackageManager {
    #[default]
    Pip,
    Poetry,
    Uv,
    Pipenv,
}

impl PackageManager {
    /// Detect package manager from lock files in project root.
    pub fn detect(root: &Path) -> Self {
        // uv.lock indicates uv (modern, fast)
        if root.join("uv.lock").exists() {
            return Self::Uv;
        }
        // poetry.lock indicates Poetry
        if root.join("poetry.lock").exists() {
            return Self::Poetry;
        }
        // Pipfile.lock or Pipfile indicates pipenv
        if root.join("Pipfile.lock").exists() || root.join("Pipfile").exists() {
            return Self::Pipenv;
        }
        // Default to pip
        Self::Pip
    }

    /// Package manager executable name.
    pub fn executable(&self) -> &'static str {
        match self {
            PackageManager::Pip => "pip",
            PackageManager::Poetry => "poetry",
            PackageManager::Uv => "uv",
            PackageManager::Pipenv => "pipenv",
        }
    }

    /// Command prefix for running Python tools.
    ///
    /// Returns the command prefix that should be used before tool names.
    /// - pip: no prefix (tools installed globally or in venv)
    /// - poetry: `poetry run`
    /// - uv: `uv run`
    /// - pipenv: `pipenv run`
    pub fn run_prefix(&self) -> Option<Vec<String>> {
        match self {
            PackageManager::Pip => None, // Direct execution
            PackageManager::Poetry => Some(vec!["poetry".into(), "run".into()]),
            PackageManager::Uv => Some(vec!["uv".into(), "run".into()]),
            PackageManager::Pipenv => Some(vec!["pipenv".into(), "run".into()]),
        }
    }
}

impl std::fmt::Display for PackageManager {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.executable())
    }
}
```

**Verification**: `cargo check` passes, module compiles

### Phase 2: Add Tool Detection for Conditional Items

Add tool detection functions to `package_manager.rs`:

```rust
/// Detected Python tooling in a project.
#[derive(Debug, Default)]
pub struct PythonTooling {
    /// Package manager detected
    pub package_manager: PackageManager,
    /// Ruff is configured
    pub has_ruff: bool,
    /// Black is configured
    pub has_black: bool,
    /// Mypy is configured
    pub has_mypy: bool,
    /// Flake8 is configured
    pub has_flake8: bool,
    /// Pylint is configured
    pub has_pylint: bool,
    /// Pytest is likely in use
    pub has_pytest: bool,
    /// Build system is configured (can run python -m build)
    pub has_build: bool,
}

impl PythonTooling {
    /// Detect Python tooling from project files.
    pub fn detect(root: &Path) -> Self {
        let package_manager = PackageManager::detect(root);
        let pyproject = root.join("pyproject.toml");
        let pyproject_content = std::fs::read_to_string(&pyproject).unwrap_or_default();

        Self {
            package_manager,
            // Ruff: ruff.toml, .ruff.toml, or [tool.ruff] in pyproject.toml
            has_ruff: root.join("ruff.toml").exists()
                || root.join(".ruff.toml").exists()
                || pyproject_content.contains("[tool.ruff]"),
            // Black: [tool.black] in pyproject.toml
            has_black: pyproject_content.contains("[tool.black]"),
            // Mypy: mypy.ini, .mypy.ini, or [tool.mypy] in pyproject.toml
            has_mypy: root.join("mypy.ini").exists()
                || root.join(".mypy.ini").exists()
                || pyproject_content.contains("[tool.mypy]"),
            // Flake8: .flake8 or setup.cfg with [flake8]
            has_flake8: root.join(".flake8").exists()
                || has_flake8_in_setup_cfg(root),
            // Pylint: .pylintrc, pylintrc, or [tool.pylint] in pyproject.toml
            has_pylint: root.join(".pylintrc").exists()
                || root.join("pylintrc").exists()
                || pyproject_content.contains("[tool.pylint]"),
            // Pytest: tests/, conftest.py, pytest.ini, or [tool.pytest] in pyproject.toml
            has_pytest: root.join("tests").is_dir()
                || root.join("conftest.py").exists()
                || root.join("pytest.ini").exists()
                || pyproject_content.contains("[tool.pytest]"),
            // Build: pyproject.toml with [build-system] or setup.py
            has_build: pyproject_content.contains("[build-system]")
                || root.join("setup.py").exists(),
        }
    }
}

/// Check if setup.cfg contains [flake8] section.
fn has_flake8_in_setup_cfg(root: &Path) -> bool {
    let setup_cfg = root.join("setup.cfg");
    if setup_cfg.exists() {
        if let Ok(content) = std::fs::read_to_string(&setup_cfg) {
            return content.contains("[flake8]");
        }
    }
    false
}
```

**Verification**: Unit tests pass for tool detection

### Phase 3: Add Python Landing Items Functions

Add to `crates/cli/src/profiles.rs`:

```rust
use crate::adapter::python::package_manager::{PackageManager as PyPackageManager, PythonTooling};

/// Python-specific Landing the Plane checklist items.
///
/// Returns default items assuming common tooling (ruff, mypy, pytest).
pub fn python_landing_items() -> &'static [&'static str] {
    &[
        "ruff check .",
        "ruff format --check .",
        "mypy .",
        "pytest",
    ]
}

/// Python-specific Landing the Plane checklist items with tooling detection.
///
/// Detects the configured tools and returns appropriate commands.
/// Only includes items for tools that are actually configured.
pub fn python_landing_items_for(root: &Path) -> Vec<String> {
    let tooling = PythonTooling::detect(root);
    let mut items = Vec::new();

    // Helper to prepend run prefix if needed
    let cmd = |tool: &str| -> String {
        if let Some(prefix) = tooling.package_manager.run_prefix() {
            format!("{} {}", prefix.join(" "), tool)
        } else {
            tool.to_string()
        }
    };

    // Linting: prefer ruff, fall back to flake8/pylint
    if tooling.has_ruff {
        items.push(cmd("ruff check ."));
    } else if tooling.has_flake8 {
        items.push(cmd("flake8"));
    }
    if tooling.has_pylint && !tooling.has_ruff {
        // Only add pylint if not using ruff (ruff replaces most pylint checks)
        items.push(cmd("pylint **/*.py"));
    }

    // Formatting: prefer ruff format, fall back to black
    if tooling.has_ruff {
        items.push(cmd("ruff format --check ."));
    } else if tooling.has_black {
        items.push(cmd("black --check ."));
    }

    // Type checking
    if tooling.has_mypy {
        items.push(cmd("mypy ."));
    }

    // Testing
    if tooling.has_pytest {
        items.push(cmd("pytest"));
    }

    // Building (only if build system is configured)
    if tooling.has_build {
        items.push(cmd("python -m build"));
    }

    // If nothing detected, return sensible defaults
    if items.is_empty() {
        return vec![
            cmd("ruff check ."),
            cmd("ruff format --check ."),
            cmd("pytest"),
        ];
    }

    items
}
```

**Verification**: Unit tests in `profiles_tests.rs` pass

### Phase 4: Export Functions and Update CLI

Update `crates/cli/src/adapter/python/mod.rs`:

```rust
// Add module declaration
mod package_manager;

pub use package_manager::{PackageManager, PythonTooling};
```

Update `crates/cli/src/cli.rs` exports:

```rust
pub use crate::profiles::{
    // ... existing exports ...
    python_landing_items, python_landing_items_for,
    // ... rest ...
};
```

**Verification**: `cargo check` passes, exports are accessible

### Phase 5: Write Unit Tests

Create `crates/cli/src/adapter/python/package_manager_tests.rs`:

```rust
#![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic)]
use super::*;
use tempfile::TempDir;

fn setup_dir() -> TempDir {
    TempDir::new().unwrap()
}

// =============================================================================
// Package Manager Detection
// =============================================================================

#[test]
fn detects_uv_from_lock_file() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("uv.lock"), "").unwrap();

    assert_eq!(PackageManager::detect(dir.path()), PackageManager::Uv);
}

#[test]
fn detects_poetry_from_lock_file() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("poetry.lock"), "").unwrap();

    assert_eq!(PackageManager::detect(dir.path()), PackageManager::Poetry);
}

#[test]
fn detects_pipenv_from_pipfile_lock() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("Pipfile.lock"), "{}").unwrap();

    assert_eq!(PackageManager::detect(dir.path()), PackageManager::Pipenv);
}

#[test]
fn detects_pipenv_from_pipfile() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("Pipfile"), "").unwrap();

    assert_eq!(PackageManager::detect(dir.path()), PackageManager::Pipenv);
}

#[test]
fn defaults_to_pip() {
    let dir = setup_dir();
    // No lock files
    assert_eq!(PackageManager::detect(dir.path()), PackageManager::Pip);
}

#[test]
fn uv_takes_precedence_over_poetry() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("uv.lock"), "").unwrap();
    std::fs::write(dir.path().join("poetry.lock"), "").unwrap();

    assert_eq!(PackageManager::detect(dir.path()), PackageManager::Uv);
}

// =============================================================================
// Tooling Detection
// =============================================================================

#[test]
fn detects_ruff_from_ruff_toml() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("ruff.toml"), "[lint]\nselect = [\"E\"]").unwrap();

    let tooling = PythonTooling::detect(dir.path());
    assert!(tooling.has_ruff);
}

#[test]
fn detects_ruff_from_pyproject_toml() {
    let dir = setup_dir();
    std::fs::write(
        dir.path().join("pyproject.toml"),
        "[tool.ruff]\nline-length = 88\n",
    )
    .unwrap();

    let tooling = PythonTooling::detect(dir.path());
    assert!(tooling.has_ruff);
}

#[test]
fn detects_mypy_from_mypy_ini() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("mypy.ini"), "[mypy]\nstrict = true").unwrap();

    let tooling = PythonTooling::detect(dir.path());
    assert!(tooling.has_mypy);
}

#[test]
fn detects_pytest_from_tests_dir() {
    let dir = setup_dir();
    std::fs::create_dir(dir.path().join("tests")).unwrap();

    let tooling = PythonTooling::detect(dir.path());
    assert!(tooling.has_pytest);
}

#[test]
fn detects_pytest_from_conftest() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("conftest.py"), "# pytest config").unwrap();

    let tooling = PythonTooling::detect(dir.path());
    assert!(tooling.has_pytest);
}

#[test]
fn detects_build_from_pyproject_build_system() {
    let dir = setup_dir();
    std::fs::write(
        dir.path().join("pyproject.toml"),
        "[build-system]\nrequires = [\"setuptools\"]\n",
    )
    .unwrap();

    let tooling = PythonTooling::detect(dir.path());
    assert!(tooling.has_build);
}

#[test]
fn detects_flake8_from_dotfile() {
    let dir = setup_dir();
    std::fs::write(dir.path().join(".flake8"), "[flake8]\nmax-line-length = 100").unwrap();

    let tooling = PythonTooling::detect(dir.path());
    assert!(tooling.has_flake8);
}

#[test]
fn detects_flake8_from_setup_cfg() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("setup.cfg"), "[flake8]\nmax-line-length = 100").unwrap();

    let tooling = PythonTooling::detect(dir.path());
    assert!(tooling.has_flake8);
}
```

Add to `crates/cli/src/profiles_tests.rs`:

```rust
// =============================================================================
// Python Landing Items
// =============================================================================

#[test]
fn python_landing_items_returns_default_commands() {
    let items = python_landing_items();
    assert_eq!(items.len(), 4);
    assert_eq!(items[0], "ruff check .");
    assert_eq!(items[1], "ruff format --check .");
    assert_eq!(items[2], "mypy .");
    assert_eq!(items[3], "pytest");
}

#[test]
fn python_landing_items_for_with_ruff_project() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("ruff.toml"), "[lint]\nselect = [\"E\"]").unwrap();
    std::fs::create_dir(dir.path().join("tests")).unwrap();

    let items = python_landing_items_for(dir.path());
    assert!(items.iter().any(|i| i.contains("ruff check")));
    assert!(items.iter().any(|i| i.contains("ruff format")));
    assert!(items.iter().any(|i| i.contains("pytest")));
}

#[test]
fn python_landing_items_for_with_poetry() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("poetry.lock"), "").unwrap();
    std::fs::write(dir.path().join("ruff.toml"), "").unwrap();
    std::fs::create_dir(dir.path().join("tests")).unwrap();

    let items = python_landing_items_for(dir.path());
    // Poetry projects should use `poetry run` prefix
    assert!(items.iter().any(|i| i.starts_with("poetry run")));
}

#[test]
fn python_landing_items_for_with_uv() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("uv.lock"), "").unwrap();
    std::fs::write(dir.path().join("ruff.toml"), "").unwrap();
    std::fs::create_dir(dir.path().join("tests")).unwrap();

    let items = python_landing_items_for(dir.path());
    // uv projects should use `uv run` prefix
    assert!(items.iter().any(|i| i.starts_with("uv run")));
}

#[test]
fn python_landing_items_for_with_pip() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("ruff.toml"), "").unwrap();
    std::fs::create_dir(dir.path().join("tests")).unwrap();

    let items = python_landing_items_for(dir.path());
    // pip projects should NOT have a run prefix
    assert!(items.iter().any(|i| i == "ruff check ."));
    assert!(!items.iter().any(|i| i.starts_with("pip run")));
}

#[test]
fn python_landing_items_for_prefers_ruff_over_flake8() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("ruff.toml"), "").unwrap();
    std::fs::write(dir.path().join(".flake8"), "[flake8]").unwrap();

    let items = python_landing_items_for(dir.path());
    // Should have ruff, not flake8
    assert!(items.iter().any(|i| i.contains("ruff check")));
    assert!(!items.iter().any(|i| i.contains("flake8")));
}

#[test]
fn python_landing_items_for_uses_flake8_when_no_ruff() {
    let dir = setup_dir();
    std::fs::write(dir.path().join(".flake8"), "[flake8]").unwrap();

    let items = python_landing_items_for(dir.path());
    assert!(items.iter().any(|i| i.contains("flake8")));
}

#[test]
fn python_landing_items_for_includes_build_when_configured() {
    let dir = setup_dir();
    std::fs::write(
        dir.path().join("pyproject.toml"),
        "[build-system]\nrequires = [\"setuptools\"]\n",
    )
    .unwrap();

    let items = python_landing_items_for(dir.path());
    assert!(items.iter().any(|i| i.contains("python -m build")));
}

#[test]
fn python_landing_items_for_omits_build_when_not_configured() {
    let dir = setup_dir();
    std::fs::write(dir.path().join("pyproject.toml"), "[project]\nname = \"test\"\n").unwrap();

    let items = python_landing_items_for(dir.path());
    assert!(!items.iter().any(|i| i.contains("python -m build")));
}
```

**Verification**: `cargo test` passes

### Phase 6: Write Behavioral Specs

Add to `tests/specs/cli/init.rs`:

```rust
// =============================================================================
// Python Landing Items Specs
// =============================================================================

/// Spec: docs/specs/langs/python.md#landing-the-plane
///
/// > Python landing items adapt to detected package manager
#[test]
fn python_landing_items_adapt_to_poetry() {
    let temp = Project::empty();
    temp.file("poetry.lock", "");
    temp.file("pyproject.toml", "[tool.ruff]\nline-length = 88\n");
    temp.dir("tests");

    let items = python_landing_items_for(temp.path());
    assert!(
        items.iter().any(|i| i.starts_with("poetry run")),
        "Poetry projects should use `poetry run` prefix"
    );
}

/// Spec: docs/specs/langs/python.md#landing-the-plane
///
/// > Python landing items include ruff when configured
#[test]
fn python_landing_items_include_ruff_when_configured() {
    let temp = Project::empty();
    temp.file("ruff.toml", "[lint]\nselect = [\"E\"]\n");

    let items = python_landing_items_for(temp.path());
    assert!(
        items.iter().any(|i| i.contains("ruff check")),
        "Should include ruff check when ruff.toml exists"
    );
    assert!(
        items.iter().any(|i| i.contains("ruff format")),
        "Should include ruff format when ruff.toml exists"
    );
}

/// Spec: docs/specs/langs/python.md#landing-the-plane
///
/// > Python landing items include mypy when configured
#[test]
fn python_landing_items_include_mypy_when_configured() {
    let temp = Project::empty();
    temp.file("mypy.ini", "[mypy]\nstrict = true\n");

    let items = python_landing_items_for(temp.path());
    assert!(
        items.iter().any(|i| i.contains("mypy")),
        "Should include mypy when mypy.ini exists"
    );
}

/// Spec: docs/specs/langs/python.md#landing-the-plane
///
/// > Python landing items include pytest when tests directory exists
#[test]
fn python_landing_items_include_pytest_when_tests_exist() {
    let temp = Project::empty();
    temp.dir("tests");

    let items = python_landing_items_for(temp.path());
    assert!(
        items.iter().any(|i| i.contains("pytest")),
        "Should include pytest when tests/ directory exists"
    );
}

/// Spec: docs/specs/langs/python.md#landing-the-plane
///
/// > Python landing items include build only when build-system configured
#[test]
fn python_landing_items_include_build_when_build_system_configured() {
    let temp = Project::empty();
    temp.file(
        "pyproject.toml",
        r#"[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"
"#,
    );

    let items = python_landing_items_for(temp.path());
    assert!(
        items.iter().any(|i| i.contains("python -m build")),
        "Should include build when [build-system] exists"
    );
}
```

**Verification**: `cargo test --test specs` passes

## Key Implementation Details

### Package Manager Detection Priority

Per `.5-roadmap-python.md`, detection order:

| Indicator | Package Manager |
|-----------|-----------------|
| `uv.lock` | uv (modern, fastest) |
| `poetry.lock` | poetry |
| `Pipfile.lock` / `Pipfile` | pipenv |
| `requirements.txt` or default | pip |

### Tool Detection Config Files

| Tool | Config Files |
|------|--------------|
| Ruff | `ruff.toml`, `.ruff.toml`, `pyproject.toml [tool.ruff]` |
| Black | `pyproject.toml [tool.black]` |
| Mypy | `mypy.ini`, `.mypy.ini`, `pyproject.toml [tool.mypy]` |
| Flake8 | `.flake8`, `setup.cfg [flake8]` |
| Pylint | `.pylintrc`, `pylintrc`, `pyproject.toml [tool.pylint]` |
| Pytest | `tests/`, `conftest.py`, `pytest.ini`, `pyproject.toml [tool.pytest]` |
| Build | `pyproject.toml [build-system]`, `setup.py` |

### Command Generation Logic

1. **Package manager prefix**: uv/poetry/pipenv projects prepend `{pm} run` to commands
2. **Linting**: Prefer ruff over flake8/pylint (ruff is faster and covers most cases)
3. **Formatting**: Prefer ruff format over black (if ruff is configured)
4. **Build**: Only include `python -m build` if build system is configured

### Integration with Profiles

The landing items functions follow the established pattern from JavaScript:
- `python_landing_items()`: Static defaults for documentation/testing
- `python_landing_items_for(root)`: Dynamic items based on project detection

## Verification Plan

1. **Unit tests**: `cargo test -p quench-cli -- python`
   - Package manager detection from lock files
   - Tool detection from config files
   - Correct command generation with prefixes

2. **Integration tests**: `cargo test --test specs -- python_landing`
   - Landing items adapt to package managers
   - Conditional tool inclusion works correctly
   - Build command only appears when configured

3. **Manual verification**:
   ```bash
   # Test with pip project
   mkdir -p /tmp/py-pip && cd /tmp/py-pip
   echo '[tool.ruff]' > pyproject.toml
   mkdir tests
   # Run quench and verify landing items

   # Test with poetry project
   mkdir -p /tmp/py-poetry && cd /tmp/py-poetry
   touch poetry.lock
   echo '[tool.ruff]' > pyproject.toml
   mkdir tests
   # Run quench and verify `poetry run` prefix

   # Test with uv project
   mkdir -p /tmp/py-uv && cd /tmp/py-uv
   touch uv.lock
   echo '[tool.ruff]' > pyproject.toml
   mkdir tests
   # Run quench and verify `uv run` prefix
   ```

4. **Full test suite**: `make check`
   - All existing tests still pass
   - No regressions in other profiles/landing items
