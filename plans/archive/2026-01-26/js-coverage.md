# JavaScript Test Runner Coverage Collection

Phase 4981 - Implement JavaScript coverage collection for Vitest, Jest, and Bun test runners.

## Overview

Add coverage collection support to the existing JavaScript test runners (Jest, Vitest, Bun). All three runners support the LCOV coverage format via `--coverage` flags. This plan adds:

1. LCOV format parsing (de facto standard for JS tooling)
2. Per-file and per-package coverage aggregation
3. Integration with each JS runner via `--coverage` flags
4. Unified JavaScript coverage in `AggregatedCoverage`

## Project Structure

```
crates/cli/src/checks/tests/runners/
├── mod.rs                 # MODIFY: add JavaScript to AggregatedCoverage
├── jest.rs                # MODIFY: integrate coverage collection
├── vitest.rs              # MODIFY: integrate coverage collection
├── bun.rs                 # MODIFY: integrate coverage collection
├── js_coverage.rs         # NEW: LCOV parsing + coverage collection
└── js_coverage_tests.rs   # NEW: unit tests

tests/specs/checks/tests/
└── coverage.rs            # MODIFY: add JavaScript coverage specs

tests/fixtures/
└── js-coverage/           # NEW: fixture with partial test coverage
    ├── package.json
    ├── src/
    │   ├── covered.js
    │   └── uncovered.js
    └── tests/
        └── covered.test.js
```

## Dependencies

No new external dependencies required. Uses:

- `std::process::Command` - execute test runners with `--coverage`
- `std::sync::OnceLock` - cache tool availability (already used by runners)
- `std::collections::HashMap` - per-file/package coverage maps
- `serde_json` - parse JSON coverage reports (already a dependency)

## Implementation Phases

### Phase 1: LCOV Format Parsing

**Goal**: Parse LCOV coverage format into `CoverageResult`.

**Files**:
- Create `crates/cli/src/checks/tests/runners/js_coverage.rs`
- Create `crates/cli/src/checks/tests/runners/js_coverage_tests.rs`

**Key Implementation**:

LCOV format (generated by Jest, Vitest, Bun, Istanbul, c8):
```
TN:testname
SF:/path/to/source.js
FN:1,functionName
FNDA:1,functionName
FNF:1
FNH:1
DA:1,1
DA:2,3
DA:3,0
LF:3
LH:2
end_of_record
```

Key fields:
- `SF:` - Source file path
- `DA:line,count` - Line data: line number and execution count
- `LF:` - Lines found (total)
- `LH:` - Lines hit (covered)
- `end_of_record` - Marks end of file record

```rust
// js_coverage.rs

/// Parse LCOV format coverage report.
///
/// LCOV is the de facto standard for JavaScript coverage tools.
/// All major JS test runners output this format.
pub fn parse_lcov_report(content: &str, duration: Duration) -> CoverageResult {
    let mut file_stats: HashMap<String, (u64, u64)> = HashMap::new(); // (hit, found)
    let mut current_file: Option<String> = None;
    let mut current_hit: u64 = 0;
    let mut current_found: u64 = 0;

    for line in content.lines() {
        let line = line.trim();
        if line.starts_with("SF:") {
            current_file = Some(line[3..].to_string());
            current_hit = 0;
            current_found = 0;
        } else if line.starts_with("LH:") {
            current_hit = line[3..].parse().unwrap_or(0);
        } else if line.starts_with("LF:") {
            current_found = line[3..].parse().unwrap_or(0);
        } else if line == "end_of_record" {
            if let Some(ref file) = current_file {
                let normalized = normalize_js_path(file);
                file_stats.insert(normalized, (current_hit, current_found));
            }
            current_file = None;
        }
    }

    // Convert to CoverageResult (same pattern as go_coverage.rs)
    calculate_coverage_result(file_stats, duration)
}
```

**Verification**:
- Unit tests in `js_coverage_tests.rs`:
  - `test_parse_lcov_empty`
  - `test_parse_lcov_single_file`
  - `test_parse_lcov_multi_file`
  - `test_parse_lcov_zero_coverage`
  - `test_parse_lcov_full_coverage`
  - `test_package_extraction_monorepo`
  - `test_node_modules_excluded`

### Phase 2: Coverage Collection Functions

**Goal**: Implement coverage collection for each JS runner.

**Files**:
- Extend `crates/cli/src/checks/tests/runners/js_coverage.rs`

**Key Implementation**:

```rust
/// Collect Jest coverage.
///
/// Runs `npx jest --coverage --coverageReporters=lcov` and parses output.
pub fn collect_jest_coverage(
    root: &Path,
    test_path: Option<&str>
) -> CoverageResult {
    let start = Instant::now();

    let mut cmd = Command::new("npx");
    cmd.args(["jest", "--coverage", "--coverageReporters=lcov"]);
    if let Some(path) = test_path {
        cmd.arg(path);
    }
    cmd.current_dir(root);
    cmd.stdout(Stdio::piped());
    cmd.stderr(Stdio::piped());

    let output = match cmd.output() {
        Ok(out) => out,
        Err(e) => {
            return CoverageResult::failed(
                start.elapsed(),
                format!("failed to run jest coverage: {e}")
            );
        }
    };

    let duration = start.elapsed();

    // Jest writes to coverage/lcov.info by default
    let lcov_path = root.join("coverage/lcov.info");
    match std::fs::read_to_string(&lcov_path) {
        Ok(content) => {
            // Cleanup coverage directory
            std::fs::remove_dir_all(root.join("coverage")).ok();
            parse_lcov_report(&content, duration)
        }
        Err(e) => {
            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                let msg = stderr.lines().take(10).collect::<Vec<_>>().join("\n");
                return CoverageResult::failed(duration, format!("jest failed:\n{msg}"));
            }
            CoverageResult::failed(duration, format!("no coverage output: {e}"))
        }
    }
}

/// Collect Vitest coverage.
///
/// Runs `npx vitest run --coverage --coverage.reporter=lcov` and parses output.
pub fn collect_vitest_coverage(
    root: &Path,
    test_path: Option<&str>
) -> CoverageResult {
    let start = Instant::now();

    let mut cmd = Command::new("npx");
    cmd.args([
        "vitest", "run",
        "--coverage",
        "--coverage.reporter=lcov"
    ]);
    if let Some(path) = test_path {
        cmd.arg(path);
    }
    cmd.current_dir(root);
    cmd.stdout(Stdio::piped());
    cmd.stderr(Stdio::piped());

    // Similar pattern: run, read lcov.info, cleanup
    // Vitest defaults to coverage/lcov.info
    // ...
}

/// Collect Bun coverage.
///
/// Runs `bun test --coverage` and parses LCOV output.
pub fn collect_bun_coverage(
    root: &Path,
    test_path: Option<&str>
) -> CoverageResult {
    let start = Instant::now();

    let mut cmd = Command::new("bun");
    cmd.args(["test", "--coverage"]);
    if let Some(path) = test_path {
        cmd.arg(path);
    }
    // Bun outputs coverage to coverage/lcov.info
    cmd.current_dir(root);
    // ...
}
```

**Verification**:
- Integration test with a simple JS fixture

### Phase 3: Runner Integration

**Goal**: Integrate coverage collection into each runner's `run()` method.

**Files**:
- Modify `crates/cli/src/checks/tests/runners/jest.rs`
- Modify `crates/cli/src/checks/tests/runners/vitest.rs`
- Modify `crates/cli/src/checks/tests/runners/bun.rs`
- Modify `crates/cli/src/checks/tests/runners/mod.rs`

**Key Implementation**:

```rust
// jest.rs - add after parsing test results

if ctx.collect_coverage {
    let coverage = collect_jest_coverage(ctx.root, config.path.as_deref());
    if let Some(line_coverage) = coverage.line_coverage {
        let mut cov_map = HashMap::new();
        cov_map.insert("javascript".to_string(), line_coverage);
        result = result.with_coverage(cov_map);
    }
    if !coverage.packages.is_empty() {
        result = result.with_package_coverage(coverage.packages);
    }
}
```

```rust
// mod.rs - extend AggregatedCoverage

pub struct AggregatedCoverage {
    pub rust: Option<CoverageResult>,
    pub shell: Option<CoverageResult>,
    pub go: Option<CoverageResult>,
    pub javascript: Option<CoverageResult>,  // NEW
}

impl AggregatedCoverage {
    /// Merge JavaScript coverage from a suite into the aggregate.
    pub fn merge_javascript(&mut self, result: CoverageResult) {
        self.javascript = Some(match self.javascript.take() {
            Some(existing) => merge_coverage_results(existing, result),
            None => result,
        });
    }

    pub fn to_coverage_map(&self) -> HashMap<String, f64> {
        let mut map = HashMap::new();
        // ... existing rust, shell, go ...
        if let Some(ref js) = self.javascript
            && let Some(pct) = js.line_coverage
        {
            map.insert("javascript".to_string(), pct);
        }
        map
    }

    pub fn has_data(&self) -> bool {
        self.rust.as_ref().is_some_and(|r| r.line_coverage.is_some())
            || self.shell.as_ref().is_some_and(|r| r.line_coverage.is_some())
            || self.go.as_ref().is_some_and(|r| r.line_coverage.is_some())
            || self.javascript.as_ref().is_some_and(|r| r.line_coverage.is_some())
    }
}
```

**Verification**:
- Run `cargo test` with all runner tests
- Verify coverage map includes `javascript` key

### Phase 4: Package Extraction for Monorepos

**Goal**: Extract per-package coverage for JavaScript monorepos.

**Files**:
- Extend `crates/cli/src/checks/tests/runners/js_coverage.rs`

**Key Implementation**:

JavaScript projects use various monorepo structures:
- `packages/<name>/src/*` - npm workspaces
- `apps/<name>/src/*` - turborepo/nx pattern
- `libs/<name>/src/*` - library pattern
- `src/*` - single package

```rust
/// Extract JavaScript package name from file path.
///
/// Examples:
/// - `packages/core/src/index.ts` -> `packages/core`
/// - `apps/web/components/Button.tsx` -> `apps/web`
/// - `src/utils/format.js` -> `root`
fn extract_js_package(path: &str) -> String {
    // Check for workspace patterns
    for marker in ["packages/", "apps/", "libs/"] {
        if let Some(idx) = path.find(marker) {
            let after_marker = &path[idx + marker.len()..];
            // Find first slash after package name
            if let Some(slash_idx) = after_marker.find('/') {
                let pkg_name = &after_marker[..slash_idx];
                return format!("{}{}", marker, pkg_name);
            }
        }
    }
    "root".to_string()
}

/// Normalize JavaScript file path for display.
///
/// Removes absolute path prefix and filters node_modules.
fn normalize_js_path(path: &str) -> String {
    // Skip node_modules entirely
    if path.contains("node_modules") {
        return String::new(); // Will be filtered out
    }

    // Find project-relative path markers
    for marker in ["src/", "lib/", "dist/", "packages/", "apps/"] {
        if let Some(idx) = path.find(marker) {
            return path[idx..].to_string();
        }
    }

    // Fallback: use filename
    path.rsplit('/').next().unwrap_or(path).to_string()
}
```

**Verification**:
- Unit tests for package extraction
- Test with monorepo fixture

### Phase 5: Test Fixture and Behavioral Specs

**Goal**: Add fixture and spec tests for JavaScript coverage.

**Files**:
- Create `tests/fixtures/js-coverage/` fixture
- Extend `tests/specs/checks/tests/coverage.rs`

**Fixture Structure**:

```
tests/fixtures/js-coverage/
├── package.json
├── jest.config.js  # or vitest.config.js
├── src/
│   ├── covered.js      # Will have tests
│   └── uncovered.js    # No tests
└── tests/
    └── covered.test.js
```

**package.json**:
```json
{
  "name": "js-coverage-fixture",
  "version": "1.0.0",
  "scripts": {
    "test": "jest"
  },
  "devDependencies": {
    "jest": "^29.0.0"
  }
}
```

**Behavioral Specs**:

```rust
// tests/specs/checks/tests/coverage.rs

// =============================================================================
// JAVASCRIPT COVERAGE
// =============================================================================

/// Spec: docs/specs/11-test-runners.md#implicit-coverage
///
/// > Jest runner provides implicit JavaScript coverage via --coverage.
#[test]
#[ignore = "TODO: Phase 4981 - JS Coverage Collection"]
fn jest_runner_collects_javascript_coverage() {
    let temp = Project::npm("js_coverage");
    temp.file("src/lib.js", r#"
export function covered() { return 42; }
export function uncovered() { return 0; }
"#);
    temp.file("tests/lib.test.js", r#"
const { covered } = require('../src/lib');
test('covered function', () => { expect(covered()).toBe(42); });
"#);
    temp.file("package.json", r#"{"name": "test", "devDependencies": {"jest": "*"}}"#);

    let result = check("tests")
        .pwd(temp.path())
        .args(&["--ci"])
        .json()
        .passes();
    let metrics = result.require("metrics");

    let coverage = metrics.get("coverage").and_then(|v| v.as_object());
    assert!(coverage.is_some());

    let js_coverage = coverage.unwrap().get("javascript").and_then(|v| v.as_f64());
    assert!(js_coverage.is_some());
    let pct = js_coverage.unwrap();
    assert!(pct > 40.0 && pct < 60.0, "Expected ~50% coverage, got {}", pct);
}

/// Spec: docs/specs/11-test-runners.md#implicit-coverage
///
/// > Vitest runner provides implicit JavaScript/TypeScript coverage.
#[test]
#[ignore = "TODO: Phase 4981 - JS Coverage Collection"]
fn vitest_runner_collects_javascript_coverage() {
    // Similar pattern with vitest
}

/// Spec: docs/specs/11-test-runners.md#implicit-coverage
///
/// > Bun runner provides implicit JavaScript/TypeScript coverage.
#[test]
#[ignore = "TODO: Phase 4981 - JS Coverage Collection"]
fn bun_runner_collects_javascript_coverage() {
    // Similar pattern with bun test --coverage
}

/// Spec: docs/specs/11-test-runners.md#aggregation
///
/// > JavaScript coverage is merged across suites.
#[test]
#[ignore = "TODO: Phase 4981 - JS Coverage Collection"]
fn multiple_js_suite_coverages_merged() {
    // Test that coverage from jest + vitest suites merges correctly
}
```

**Verification**:
- `cargo test --test specs -- coverage` passes
- Behavioral tests match spec

## Key Implementation Details

### LCOV Line Parsing

The LCOV format is line-oriented with specific prefixes:

```rust
fn parse_lcov_line(line: &str) -> Option<LcovField> {
    let line = line.trim();
    if line.starts_with("SF:") {
        Some(LcovField::SourceFile(line[3..].to_string()))
    } else if line.starts_with("DA:") {
        // DA:line_number,execution_count
        let parts: Vec<&str> = line[3..].split(',').collect();
        if parts.len() == 2 {
            let line_num: u32 = parts[0].parse().ok()?;
            let count: u64 = parts[1].parse().ok()?;
            Some(LcovField::LineData(line_num, count))
        } else {
            None
        }
    } else if line.starts_with("LH:") {
        Some(LcovField::LinesHit(line[3..].parse().ok()?))
    } else if line.starts_with("LF:") {
        Some(LcovField::LinesFound(line[3..].parse().ok()?))
    } else if line == "end_of_record" {
        Some(LcovField::EndOfRecord)
    } else {
        None
    }
}
```

### Coverage File Cleanup

Each runner writes coverage to a standard location:

| Runner  | Coverage Location          |
|---------|----------------------------|
| Jest    | `coverage/lcov.info`       |
| Vitest  | `coverage/lcov.info`       |
| Bun     | `coverage/lcov.info`       |

Cleanup after reading:
```rust
std::fs::remove_dir_all(root.join("coverage")).ok();
```

### Node Modules Exclusion

Always exclude `node_modules` from coverage metrics:

```rust
fn should_include_file(path: &str) -> bool {
    !path.contains("node_modules")
}
```

### Concurrent Test Execution Consideration

If multiple JS suites run concurrently, they may conflict on the `coverage/` directory. Options:
1. Run coverage collection sequentially (simplest)
2. Use unique output directories per runner

For Phase 4981, use sequential collection for simplicity.

## Verification Plan

### Unit Tests

Run after Phase 1:
```bash
cargo test -p quench-cli -- js_coverage
```

### Integration Tests

After Phase 3:
```bash
cargo test -p quench-cli -- jest_runner vitest_runner bun_runner
```

### Behavioral Tests

After Phase 5:
```bash
cargo test --test specs -- coverage
```

### Manual Verification

```bash
# Build quench
cargo build --release

# Test on js-coverage fixture
./target/release/quench check --ci --tests -C tests/fixtures/js-coverage

# Verify coverage output shows JavaScript percentage
# Expected: "coverage: javascript: XX.X%"
```

### Full CI Check

Before committing:
```bash
make check
```

Ensures:
- `cargo fmt --all -- --check`
- `cargo clippy --all-targets --all-features -- -D warnings`
- `cargo test --all`
- `cargo build --all`
- `cargo audit`
- `cargo deny check`
