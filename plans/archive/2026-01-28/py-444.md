# Phase 444: Python Test Fixtures

## Overview

Create test fixtures for Python language adapter validation. This includes three fixture projects demonstrating different Python project layouts and package managers, plus Python-specific violations in the violations fixture.

## Project Structure

```
tests/fixtures/
├── python-simple/           # Basic Python project (pyproject.toml, src/, tests/)
│   ├── pyproject.toml
│   ├── quench.toml
│   ├── src/
│   │   └── example/
│   │       ├── __init__.py
│   │       └── math.py
│   └── tests/
│       └── test_math.py
│
├── python-poetry/           # Poetry-managed project
│   ├── pyproject.toml
│   ├── poetry.lock
│   ├── quench.toml
│   ├── src/
│   │   └── poetryapp/
│   │       ├── __init__.py
│   │       └── utils.py
│   └── tests/
│       └── test_utils.py
│
├── python-uv/               # uv-managed project
│   ├── pyproject.toml
│   ├── uv.lock
│   ├── quench.toml
│   ├── src/
│   │   └── uvapp/
│   │       ├── __init__.py
│   │       └── core.py
│   └── tests/
│       └── test_core.py
│
└── violations/
    └── py/                  # Python violations (new directory)
        ├── noqa.py          # # noqa without justification
        ├── type_ignore.py   # # type: ignore without justification
        ├── eval_escape.py   # eval() without EVAL comment
        ├── exec_escape.py   # exec() without EXEC comment
        └── breakpoint.py    # breakpoint() in source
```

## Dependencies

None. Test fixtures are static files requiring no external dependencies.

## Implementation Phases

### Phase 1: python-simple fixture

Create minimal Python project using src-layout with `pyproject.toml`:

**pyproject.toml:**
```toml
[project]
name = "example"
version = "0.1.0"
requires-python = ">=3.10"

[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[tool.setuptools.packages.find]
where = ["src"]
```

**quench.toml:**
```toml
version = 1

[project]
name = "python-simple"

[[check.tests.suite]]
runner = "pytest"
```

**src/example/__init__.py:**
```python
"""Example package."""
```

**src/example/math.py:**
```python
"""Simple math operations."""

def add(a: int, b: int) -> int:
    """Return the sum of two integers."""
    return a + b

def multiply(a: int, b: int) -> int:
    """Return the product of two integers."""
    return a * b
```

**tests/test_math.py:**
```python
"""Tests for math module."""
from example.math import add, multiply

def test_add():
    assert add(2, 3) == 5

def test_multiply():
    assert multiply(4, 5) == 20
```

### Phase 2: python-poetry fixture

Create Poetry-managed project with `poetry.lock`:

**pyproject.toml:**
```toml
[tool.poetry]
name = "poetryapp"
version = "0.1.0"
description = "Poetry-managed Python project"
authors = ["Test Author <test@example.com>"]

[tool.poetry.dependencies]
python = "^3.10"

[tool.poetry.group.dev.dependencies]
pytest = "^8.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

**poetry.lock:**
```toml
# This file is automatically @generated by Poetry.
[[package]]
name = "pytest"
version = "8.0.0"
description = "pytest: simple powerful testing with Python"
python-versions = ">=3.8"
```

**quench.toml:**
```toml
version = 1

[project]
name = "python-poetry"

[[check.tests.suite]]
runner = "pytest"
```

**src/poetryapp/utils.py:**
```python
"""Utility functions."""

def greet(name: str) -> str:
    """Return a greeting for the given name."""
    return f"Hello, {name}!"
```

**tests/test_utils.py:**
```python
"""Tests for utils module."""
from poetryapp.utils import greet

def test_greet():
    assert greet("World") == "Hello, World!"
```

### Phase 3: python-uv fixture

Create uv-managed project with `uv.lock`:

**pyproject.toml:**
```toml
[project]
name = "uvapp"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = []

[project.optional-dependencies]
dev = ["pytest>=8.0"]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/uvapp"]
```

**uv.lock:**
```toml
version = 1

[[package]]
name = "uvapp"
version = "0.1.0"
source = { editable = "." }

[[package]]
name = "pytest"
version = "8.0.0"
```

**quench.toml:**
```toml
version = 1

[project]
name = "python-uv"

[[check.tests.suite]]
runner = "pytest"
```

**src/uvapp/core.py:**
```python
"""Core functionality."""

def process(data: list[str]) -> list[str]:
    """Process a list of strings by uppercasing."""
    return [s.upper() for s in data]
```

**tests/test_core.py:**
```python
"""Tests for core module."""
from uvapp.core import process

def test_process():
    assert process(["hello", "world"]) == ["HELLO", "WORLD"]
```

### Phase 4: Python violations

Add Python-specific violations to `tests/fixtures/violations/py/`:

**py/noqa.py:**
```python
# VIOLATION: # noqa without justification comment
x = 1  # noqa: E501
```

**py/type_ignore.py:**
```python
# VIOLATION: # type: ignore without justification comment
value: str = 123  # type: ignore
```

**py/eval_escape.py:**
```python
# VIOLATION: eval() without EVAL comment
result = eval("1 + 2")
```

**py/exec_escape.py:**
```python
# VIOLATION: exec() without EXEC comment
exec("x = 42")
```

**py/breakpoint.py:**
```python
# VIOLATION: breakpoint() in source code (forbidden)
def debug_something():
    breakpoint()
    return 42
```

### Phase 5: Update fixture README

Update `tests/fixtures/CLAUDE.md` to document the new Python fixtures:

Add entries to the Fixture Index table and add detail sections for each Python fixture following the existing format.

## Key Implementation Details

### Package Manager Detection

Each fixture demonstrates a different package manager indicator:

| Fixture | Indicator | Package Manager |
|---------|-----------|-----------------|
| python-simple | `pyproject.toml` only | pip (modern) |
| python-poetry | `poetry.lock` | poetry |
| python-uv | `uv.lock` | uv |

### Project Layout

All fixtures use the recommended src-layout:
- `src/<package_name>/__init__.py` pattern
- Clear separation between source and tests
- Tests directory at project root

### Python Violations Mapping

| Check | File | Violation | From Roadmap |
|-------|------|-----------|--------------|
| suppress | `py/noqa.py` | `# noqa` without comment | Phase 446 |
| suppress | `py/type_ignore.py` | `# type: ignore` without comment | Phase 446 |
| escapes | `py/eval_escape.py` | `eval()` without EVAL comment | Phase 445 |
| escapes | `py/exec_escape.py` | `exec()` without EXEC comment | Phase 445 |
| escapes | `py/breakpoint.py` | `breakpoint()` forbidden | Phase 445 |

## Verification Plan

1. **Phase 1 verification:**
   - Directory structure matches expected layout
   - `pyproject.toml` is valid TOML with `[project]` section
   - Python files are syntactically valid

2. **Phase 2 verification:**
   - `poetry.lock` file present
   - `[tool.poetry]` section in pyproject.toml
   - Poetry-specific build system configured

3. **Phase 3 verification:**
   - `uv.lock` file present
   - Modern pyproject.toml with `[project]` section
   - Hatchling build backend configured

4. **Phase 4 verification:**
   - Each violation file contains exactly one violation type
   - Comment explains the expected violation
   - Violations match patterns from roadmap Phase 445/446

5. **Phase 5 verification:**
   - README includes all three Python fixtures in index
   - Detail sections document each fixture's purpose
   - Python violations added to violations table

6. **Integration verification (after Python adapter phases):**
   - `quench check` on python-simple produces useful output
   - Package manager detection works for each fixture
   - Violations fixture triggers expected Python escapes/suppress checks
